% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/anchor_seed.R
\name{anchor.seed}
\alias{anchor.seed}
\title{Identify seed cells}
\usage{
anchor.seed(
  attTbl,
  ngbList,
  rNumb = FALSE,
  class = NULL,
  cond.filter = NULL,
  cond.seed,
  sort.seed = NULL,
  sort.col = NULL,
  cond.growth = NULL,
  lag.growth = Inf,
  cond.isol = NULL,
  lag.isol = 1,
  saveRDS = NULL,
  overWrite = FALSE,
  isolationBuff = FALSE,
  silent = FALSE
)
}
\arguments{
\item{attTbl}{data.frame, the attribute table returned by the function
\code{\link{attTbl}}.}

\item{ngbList}{list, the list of neighborhoods returned by the function
\code{\link{ngbList}}.}

\item{rNumb}{logic, the neighborhoods of the argument \code{ngbList} are
identified by cell numbers (\code{rNumb=FALSE}) or by row numbers
(\code{rNumb=TRUE}) (see \code{\link{ngbList}}). It is advised to use row
numbers for large rasters.}

\item{class}{numeric, the classification number to assign to all cells that
meet the function conditions. If \code{NULL}, a new class numbers is
assigned every time a new seed cell is identified. Growth buffers have the
same classification number as the seed cell to which they refer.}

\item{cond.filter}{character string, the conditions to define for what cells
the arguments \code{cond.seed}, \code{cond.growth} and \code{cond.isol}
have to be evaluated. It can be \code{NULL}. Absolute conditions can be
used (see \code{\link{conditions}}).}

\item{cond.seed}{character string, the conditions to identify seed cells.
Absolute conditions can be used (see \code{\link{conditions}}), including
\code{"variable_x == max(variable_x)"} or \code{"variable_x ==
  min(variable_x)"} if seed cell correspond to local maxima or minima. It
cannot be \code{NULL}.}

\item{sort.seed}{character, sort seeds based on column values. If
\code{"max"}, seeds are evaluated from the maximum to the minimum. If
\code{"min"}, seeds are evaluated from the minimum to the maximum.}

\item{sort.col}{character, the column name in the \code{attTbl} on which the
\code{sort.seed} is based on.}

\item{cond.growth}{character string, the conditions to define a growth buffer
around seed cells. It can be \code{NULL}. Absolute and focal cell
conditions can be used (see \code{\link{conditions}}).}

\item{lag.growth}{numeric, it defines the lag on which focal cell conditions
in \code{cond.growth} are evaluated.}

\item{cond.isol}{character string, the conditions to define an isolation
buffer around seed cells. It can be \code{NULL}. Absolute and focal cell
conditions can be used (see \code{\link{conditions}}).}

\item{lag.isol}{numeric, it defines the lag on which focal cell conditions in
\code{cond.isol} are evaluated.}

\item{saveRDS}{filename, if a file name is provided save the class vector as
an RDS file.}

\item{overWrite}{logic, if the RDS names already exist, existing files are
overwritten.}

\item{isolationBuff}{logic, return the isolation buffer (class = -1).}

\item{silent}{logic, progress is not printed on the console.}
}
\value{
Classification vector.
}
\description{
Returns a vector of cell numbers at the locations of seed cells.
}
\details{
This function implements an algorithm to identify seed cells, growth
buffers and isolation buffers.

\cr\strong{Condition arguments}

The function takes as inputs four sets of conditions with
\code{cond.growth} and \code{cond.isol} taking into account class
contiguity and continuity (see \code{\link{conditions}}):
\enumerate{
\item \strong{\code{cond.filter}}, the conditions to define what cells have to be
evaluated by the function.
\item \strong{\code{cond.seed}}, the conditions to identify, at each iteration, the
seed cell. The seed cell is the cell around which growth and isolation
conditions are applied.
\item \strong{\code{cond.growth}}, the conditions to define a buffer around the
seed cell.
\item \strong{\code{cond.isol}}, the conditions to isolate one seed cell (and its
growth buffer) from another.
}

\cr\strong{Iterations}
\itemize{
\item The argument \code{cond.filter} defines the set of cells to be considered
by the function.
\item A seed cell is identified based on \code{cond.seed} and receives a
classification number as specified by the argument \code{class}. If
\code{class=NULL}, then a new class is assigned to every new seed cell.
\item Cells continuous and continuous to the seed cell meeting the conditions
specified by \code{cond.growth} are assigned to the same class of the seed
cell (growth buffer).
\item Cells continuous and continuous to the seed cell (and its growth buffer)
meeting the conditions specified by \code{cond.isol} are assigned to the
isolation buffer (\code{class = -1}).
\item A new seed cell is identified and a new iteration starts. Seed, growth
and isolation cells identified in previous iteration are ignored in
successive iterations.
\item The function stops when it cannot identify any new seed cell.
}

\cr\strong{Node structure}
\itemize{
\item The evaluation of \code{cond.growth} and \code{cond.isol} follows a node
structure. Let us consider \code{cond.growth} as an example.
\item At \code{level_0} there is a single node, a cell previously classified as
\code{seed}. Every unclassified cell adjacent to the node in \code{level_0}
that evaluates positively to \code{cond.growth} becomes a \code{level_1}
node. The \code{level_0} cell becomes the \code{referenceNode} for
\code{level_1}
\item Then, the algorithm considers the first node at \code{level_1}.
Unclassified cells adjacent to the first node evaluating positively to
\code{cond.growth} become \code{level_2} nodes. The first node of
\code{level_1} is set as a \code{referenceNode} for \code{level_2}.
\item The algorithm then evaluates if one or more cells adjacent to the first
node in \code{level_2} evaluate positively to \code{cond.growth}. If any
does, then the first node of \code{level_2} is set as \code{referenceNode}
for \code{level_3}.
\item The algorithm continues in this way until \code{level_n} where none of
the adjacent cells evaluate positively to \code{cond.growth}.
\item At this point the algorithm considers cells adjacent to the second node
at \code{level_n-1}. If any cell has a positive evaluation, then second
node in \code{level_n-1} is set as \code{referenceNode} for \code{level_n}
and the algorithm continues as described above.
\item On the contrary, if none of the cells evaluate positively to
\code{cond.growth}, the algorithm will remain at at \code{level_n-1} and
will consider the next node. If none of the nodes at \code{level_n-1} has
any neighboring cell evaluating positively to \code{cond.growth}, then the
algorithm will move down to \code{level_n-2}.
\item The evaluation of \code{cond.growth} will stop once the algorithm returns
to \code{level_0}.
}

\strong{Relative conditions and evaluation lag}
This implementation allows to track back to \code{level_0} all the
connected cells having a positive evaluation. When conditions relative to
the focal cell are considered (see \code{\link{conditions}}), the arguments
\code{lag.growth} and \code{lag.isol} determine to which
\code{referenceNode} newly evaluated cells have to be compared to. A lag of
\code{1} indicates that the conditions at \code{level_n} have to be
evaluated considering the \code{referenceNode} at \code{level_n-1}. A lag
set as \code{Inf} indicates that at any level the conditions are evaluated
considering the initial node cell at \code{level_0}. If the lag is greater
than the level at which the evaluation occurs, then the conditions are
evaluated considering the initial node cell at \code{level_0} (e.g.,
\code{level_1}, \code{lag = 2}).
}
\examples{
# DUMMY DATA
############################################################################
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD THE DUMMY RASTER
r <- list.files(system.file("extdata", package = "scapesClassification"),
                pattern = "dummy_raster\\\\.tif", full.names = TRUE)
r <- terra::rast(r)

# COMPUTE THE ATTRIBUTE TABLE
at <- attTbl(r, "dummy_var")

# COMPUTE THE LIST OF NEIGBORHOODS
nbs <- ngbList(r)

# SET FIGURE MARGINS
m <- c(4.2, 1, 1, 15)

############################################################################
# EXAMPLE PLOTS
############################################################################
# 1.
as <- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var > 1", cond.seed = "dummy_var == max(dummy_var)")

plot(cv.2.rast(r,classVector = as), type="classes", mar=m, col=terrain.colors(30)[-1],
     asp=NA, axes=FALSE, plg=list(x=1, y=1, cex=.75, title="Classes", y.intersp= 1.4))
text(r)
lines(r)
mtext(side=1, line=0, cex=0.9, font=2, adj=0, "cond.filter:")
mtext(side=1, line=0, cex=0.9, adj=1, "dummy_var > 1")
mtext(side=1, line=1, cex=0.9, font=2, adj=0, "cond.seed:")
mtext(side=1, line=1, cex=0.9, adj=1, "dummy_var == max(dummy_var)")
mtext(side=1, line=2, cex=0.9, font=2, adj=0, "cond.growth:")
mtext(side=1, line=2, cex=0.9, adj=1, "NULL")
mtext(side=1, line=3, cex=0.9, font=2, adj=0, "cond.isol:")
mtext(side=1, line=3, cex=0.9, adj=1, "NULL")

# 2.
as <- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var > 1", cond.seed = "dummy_var == max(dummy_var)",
                  cond.growth = "dummy_var<dummy_var[] & dummy_var>2")

plot(cv.2.rast(r,classVector = as), type="classes", mar=m, asp=NA,
     axes=FALSE, plg=list(x=1, y=1, cex=.75, title="Classes", y.intersp= 1.4))
text(r)
lines(r)
mtext(side=1, line=0, cex=0.9, font=2, adj=0, "cond.filter:")
mtext(side=1, line=0, cex=0.9, adj=1, "dummy_var > 1")
mtext(side=1, line=1, cex=0.9, font=2, adj=0, "cond.seed:")
mtext(side=1, line=1, cex=0.9, adj=1, "dummy_var == max(dummy_var)")
mtext(side=1, line=2, cex=0.9, font=2, adj=0, "cond.growth:")
mtext(side=1, line=2, cex=0.9, adj=1, "dummy_var<dummy_var[] & dummy_var>2")
mtext(side=1, line=3, cex=0.9, font=2, adj=0, "cond.isol:")
mtext(side=1, line=3, cex=0.9, adj=1, "NULL")

# 3.
as <- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var > 1", cond.seed = "dummy_var == max(dummy_var)",
                  cond.growth = "dummy_var<dummy_var[] & dummy_var>2",
                  cond.isol = "dummy_var<dummy_var[]")

plot(cv.2.rast(r,classVector = as), type="classes", mar=m, asp=NA,
     axes=FALSE, plg=list(x=1, y=1, cex=.75, title="Classes", y.intersp= 1.4))
text(r)
lines(r)
mtext(side=1, line=0, cex=0.9, font=2, adj=0, "cond.filter:")
mtext(side=1, line=0, cex=0.9, adj=1, "dummy_var > 1")
mtext(side=1, line=1, cex=0.9, font=2, adj=0, "cond.seed:")
mtext(side=1, line=1, cex=0.9, adj=1, "dummy_var == max(dummy_var)")
mtext(side=1, line=2, cex=0.9, font=2, adj=0, "cond.growth:")
mtext(side=1, line=2, cex=0.9, adj=1, "dummy_var<dummy_var[] & dummy_var>2")
mtext(side=1, line=3, cex=0.9, font=2, adj=0, "cond.isol:")
mtext(side=1, line=3, cex=0.9, adj=1, "dummy_var<dummy_var[]")

# 4.
as <- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.seed = "dummy_var >= 5", cond.growth = "dummy_var >= 5")

plot(cv.2.rast(r,classVector = as), type="classes", mar=m, asp=NA,
     axes=FALSE, plg=list(x=1, y=1, cex=.75, title="Classes", y.intersp= 1.4))
text(r)
lines(r)
mtext(side=1, line=0, cex=0.9, font=2, adj=0, "cond.filter:")
mtext(side=1, line=0, cex=0.9, adj=1, "NULL")
mtext(side=1, line=1, cex=0.9, font=2, adj=0, "cond.seed:")
mtext(side=1, line=1, cex=0.9, adj=1, "dummy_var >= 5")
mtext(side=1, line=2, cex=0.9, font=2, adj=0, "cond.growth:")
mtext(side=1, line=2, cex=0.9, adj=1, "dummy_var >= 5")
mtext(side=1, line=3, cex=0.9, font=2, adj=0, "cond.isol:")
mtext(side=1, line=3, cex=0.9, adj=1, "NULL")

# 5.
as <- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var > 1", cond.seed = "dummy_var == max(dummy_var)",
                  cond.growth = "dummy_var<dummy_var[]", lag.growth = Inf)

plot(cv.2.rast(r,classVector = as), type="classes", mar=m, asp=NA,
     axes=FALSE, plg=list(x=1, y=1, cex=.75, title="Classes", y.intersp= 1.4))
text(r)
lines(r)
mtext(side=1, line=0, cex=0.9, font=2, adj=0, "cond.filter:")
mtext(side=1, line=0, cex=0.9, adj=1, "dummy_var > 1")
mtext(side=1, line=1, cex=0.9, font=2, adj=0, "cond.seed:")
mtext(side=1, line=1, cex=0.9, adj=1, "dummy_var == max(dummy_var)")
mtext(side=1, line=2, cex=0.9, font=2, adj=0, "cond.growth (LAG = INF):")
mtext(side=1, line=2, cex=0.9, adj=1, "dummy_var<dummy_var[]")
mtext(side=1, line=3, cex=0.9, font=2, adj=0, "cond.isol:")
mtext(side=1, line=3, cex=0.9, adj=1, "NULL")

# 6.
as <- anchor.seed(attTbl = at, ngbList = nbs, rNumb = FALSE, class = NULL, silent = TRUE,
                  cond.filter = "dummy_var > 1", cond.seed = "dummy_var == max(dummy_var)",
                  cond.growth = "dummy_var<dummy_var[]", lag.growth = 0)

plot(cv.2.rast(r,classVector = as), type="classes", mar=m, asp=NA,
     axes=FALSE, plg=list(x=1, y=1, cex=.75, title="Classes", y.intersp= 1.4))
text(r)
lines(r)
mtext(side=1, line=0, cex=0.9, font=2, adj=0, "cond.filter:")
mtext(side=1, line=0, cex=0.9, adj=1, "dummy_var > 1")
mtext(side=1, line=1, cex=0.9, font=2, adj=0, "cond.seed:")
mtext(side=1, line=1, cex=0.9, adj=1, "dummy_var == max(dummy_var)")
mtext(side=1, line=2, cex=0.9, font=2, adj=0, "cond.growth (LAG = 0):")
mtext(side=1, line=2, cex=0.9, adj=1, "dummy_var<dummy_var[]")
mtext(side=1, line=3, cex=0.9, font=2, adj=0, "cond.isol:")
mtext(side=1, line=3, cex=0.9, adj=1, "NULL")
}
\seealso{
\code{\link[=conditions]{conditions()}}, \code{\link[=attTbl]{attTbl()}}, \code{\link[=ngbList]{ngbList()}}
}
