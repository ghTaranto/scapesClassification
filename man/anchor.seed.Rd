% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/anchorSeed.R
\name{anchor.seed}
\alias{anchor.seed}
\title{Set Anchor Cells from Local Minima or Local Maxima}
\usage{
anchor.seed(
  attTbl,
  ngbList,
  nbsIndex = FALSE,
  class = NULL,
  cond.filter = NULL,
  cond.seed,
  cond.growth = NULL,
  lag.growth = Inf,
  cond.isol = NULL,
  lag.isol = 1,
  classVector = NULL,
  saveRDS = NULL,
  overWrite = FALSE,
  isolationClass = FALSE,
  silent = FALSE
)
}
\arguments{
\item{attTbl}{data.frame, the attribute table returned by the function
\code{\link{attTbl}}.}

\item{ngbList}{list, it has to contain the list of 8-neighbors of each cell
in \code{attTbl$Cell} (see \code{\link{ngbList}}).}

\item{nbsIndex}{logic, \code{ngbList} contain the neighbors index position
in the attribute table (see \code{\link{ngbList}}).}

\item{class}{numeric, the numeric class to attribute to local minima or
maxima. If \code{NULL} then each local minima or maxima is classified with
a different number starting from one. Buffers have the same classification
number as the local minima or maxima to which they refer.}

\item{cond.filter}{character string, the conditions to define for what cells
the arguments \code{cond.seed}, \code{cond.growth} and \code{cond.isol}
have to be evaluated. It can be \code{NULL}. Absolute conditions can be
used (see \code{\link{conditions}}).}

\item{cond.seed}{character string, the conditions to identify local maxima or
minima. The condition should be similar to \code{"variable_x ==
  max(variable_x)"} or \code{"variable_x == min(variable_x)"}. It cannot be
\code{NULL}.}

\item{cond.growth}{character string, the conditions to define a buffer around
local maxima or minima. It can be \code{NULL}. Absolute and focal cell
conditions can be used (see \code{\link{conditions}}).}

\item{lag.growth}{numeric, it defines the lag on which focal cell conditions
in \code{cond.growth} are evaluated (see \code{\link{conditions}}).}

\item{cond.isol}{character string, the conditions to define how one local
maxima or minima is isolated from another. It can be \code{NULL}. Absolute
and focal cell conditions can be used (see \code{\link{conditions}}).}

\item{lag.isol}{numeric, it defines the lag on which focal cell conditions in
\code{cond.isol} are evaluated (see \code{\link{conditions}}).}

\item{classVector}{numeric vector, if any of the condition arguments refers
to a previous classification, then this classification have to be referred
as \code{"classVector"}.}

\item{saveRDS}{filename, if a file name is provided save the anchor cell
vector as an RDS file.}

\item{overWrite}{logic, if the RDS names already exist, existing files are
overwritten.}

\item{isolationClass}{logic, return cells meeting isolation conditions
(\code{isolator cells}) classified as \code{'-1'}.}

\item{silent}{logic, progress is not printed on the console.}
}
\value{
Classification vector.
}
\description{
Returns a vector of cell numbers at the locations of local minima or local
maxima. These cells can be used as anchor cells in other
\code{scapesClassification} functions.
}
\details{
This function implements an algorithm to identify local maxima or
minima based on a set of \code{\link{conditions}}. It is possible to
identify local maxima or minima considering only a subset of cells using
the argument \code{cond.filter}.

The algorithm starts identifying the cell(s) meeting the conditions of the
argument \code{cond.seed}. This cell(s) can be referred to as \code{seed}
cell(s). If a \code{cond.growth} argument is provided, all cells around the
\code{seed} meeting the conditions of \code{cond.growth} are also
classified as \code{seed}. The algorithm will continue looking for new
\code{seed} cells as long as among the neighbors of the newly classified
\code{seed} cells there are cells that meet the conditions of
\code{cond.growth}. In the next step, cells adjacent to \code{seed} cells
meeting the conditions of the argument \code{cond.isol} are classified as
\code{isolator} cells. As for \code{seed} cells, the algorithm will
continue looking for \code{isolator} cells as long as among the neighbors
of the newly classified \code{isolator} cells there are cells that meet the
conditions of \code{cond.isol}. When a cell is classified either as
\code{seed} or as \code{isolator}, then it is ignored in all successive
iterations of the algorithm. The \code{cond.seed}, \code{cond.growth},
\code{cond.isol} process is repeated until all cells are classified either
as \code{seed} or as \code{isolator}.

The evaluation of \code{cond.growth} and \code{cond.isol} follows a node
structure. Let us consider \code{cond.growth} as an example and refer to
'the conditions of the \code{cond.growth} argument' simply as \code{cond}.
At \code{level_0} there is a single node, a cell previously classified as
\code{seed}. Each cell adjacent to the node in \code{level_0} that evaluate
positively to \code{cond} represents a node at \code{level_1}. Suppose that
at \code{level_1} there are one or more nodes. The algorithm then considers
the first of these nodes and looks for neighbor cells evaluating positively
to \code{cond}. If one or more cells do, then the first node of
\code{level_1} is set as \code{referenceNode} for \code{level_2}. The
algorithm then evaluates if one or more cells adjacent to the first node in
\code{level_2} evaluate positively to \code{cond}. If any does, then the
first node of \code{level_2} is set as \code{referenceNode} for
\code{level_3}. The algorithm continues in this way until \code{level_n}
where none of the adjacent cells evaluate positively to \code{cond}. At
this point the algorithm considers cells adjacent to the second node at
\code{level_n-1}. If any cell has a positive evaluation, then second node
in \code{level_n-1} is set as \code{referenceNode} for \code{level_n} and
the algorithm continues as described above. On the contrary, if none of the
cells evaluate positively to \code{cond}, the algorithm will remain at at
\code{level_n-1} and will consider the next node. If none of the nodes at
\code{level_n-1} has any neighboring cell evaluating positively to
\code{cond}, then the algorithm will move down to \code{level_n-2}. The
evaluation of \code{cond.growth} will stop once the algorithm returns to
\code{level_0}.

This implementation allows to track back to \code{level_0} all the
connected cells having a positive evaluation. When conditions relative to
the focal cell are considered (see \code{\link{conditions}}), the arguments
\code{lag.growth} and \code{lag.isol} determine to which
\code{referenceNode} newly evaluated cells have to be compared to. A lag of
\code{1} indicates that the conditions at \code{level_n} have to be
evaluated considering the \code{referenceNode} at \code{level_n-1}. A lag
set as \code{Inf} indicates that at any level the conditions are evaluated
considering the initial node cell at \code{level_0}. If the lag is greater
than the level at which the evaluation occurs, then the conditions are
evaluated considering the initial node cell at \code{level_0} (e.g.,
\code{level_1}, \code{lag = 2}).
}
\seealso{
\code{\link[=conditions]{conditions()}}, \code{\link[=attTbl]{attTbl()}}, \code{\link[=ngbList]{ngbList()}}
}
