% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/anchor_seed.R
\name{anchor.seed}
\alias{anchor.seed}
\title{Identify seed cells}
\usage{
anchor.seed(
  attTbl,
  ngbList,
  rNumb = FALSE,
  class = NULL,
  cond.filter = NULL,
  cond.seed,
  sort.seed = NULL,
  sort.col = NULL,
  cond.growth = NULL,
  lag.growth = Inf,
  cond.isol = NULL,
  lag.isol = 1,
  saveRDS = NULL,
  overWrite = FALSE,
  isolationBuff = FALSE,
  silent = FALSE
)
}
\arguments{
\item{attTbl}{data.frame, the attribute table returned by the function
\code{\link{attTbl}}.}

\item{ngbList}{list, the list of neighborhoods returned by the function
\code{\link{ngbList}}.}

\item{rNumb}{logic, the neighborhoods of the argument \code{ngbList} are
identified by cell numbers (\code{rNumb=FALSE}) or by row numbers
(\code{rNumb=TRUE}) (see \code{\link{ngbList}}). It is advised to use row
numbers for large rasters.}

\item{class}{numeric, the classification number to assign to all cells that
meet the function conditions. If \code{NULL}, a new class numbers is
assigned every time a new seed cell is identified. Growth buffers have the
same classification number as the seed cell to which they refer.}

\item{cond.filter}{character string, the conditions to define for what cells
the arguments \code{cond.seed}, \code{cond.growth} and \code{cond.isol}
have to evaluated. It can be \code{NULL}. Absolute conditions can be
used (see \code{\link{conditions}}).}

\item{cond.seed}{character string, the conditions to identify seed cells.
Absolute conditions can be used (see \code{\link{conditions}}), including
\code{"variable_x == max(variable_x)"} or \code{"variable_x ==
  min(variable_x)"} if seed cell correspond to local maxima or minima. It
cannot be \code{NULL}.}

\item{sort.seed}{character, sort seeds based on column values. If
\code{"max"}, seeds are evaluated from the maximum to the minimum. If
\code{"min"}, seeds are evaluated from the minimum to the maximum.}

\item{sort.col}{character, the column name in the \code{attTbl} on which the
\code{sort.seed} is based on.}

\item{cond.growth}{character string, the conditions to define a growth buffer
around seed cells. It can be \code{NULL}. Absolute and focal cell
conditions can be used (see \code{\link{conditions}}).}

\item{lag.growth}{numeric, it defines the lag on which focal cell conditions
in \code{cond.growth} are evaluated.}

\item{cond.isol}{character string, the conditions to define an isolation
buffer around seed cells. It can be \code{NULL}. Absolute and focal cell
conditions can be used (see \code{\link{conditions}}).}

\item{lag.isol}{numeric, it defines the lag on which focal cell conditions in
\code{cond.isol} are evaluated.}

\item{saveRDS}{filename, if a file name is provided save the anchor cell
vector as an RDS file.}

\item{overWrite}{logic, if the RDS names already exist, existing files are
overwritten.}

\item{isolationBuff}{logic, return the isolation buffer (class = -1)..}

\item{silent}{logic, progress is not printed on the console.}
}
\value{
Classification vector.
}
\description{
Returns a vector of cell numbers at the locations of seed cells.
}
\details{
This function implements an algorithm to identify local maxima or
minima based on a set of \code{\link{conditions}}. It is possible to
identify local maxima or minima considering only a subset of cells using
the argument \code{cond.filter}.

The algorithm starts identifying the cell(s) meeting the conditions of the
argument \code{cond.seed}. This cell(s) can be referred to as \code{seed}
cell(s). If a \code{cond.growth} argument is provided, all cells around the
\code{seed} meeting the conditions of \code{cond.growth} are also
classified as \code{seed}. The algorithm will continue looking for new
\code{seed} cells as long as among the neighbors of the newly classified
\code{seed} cells there are cells that meet the conditions of
\code{cond.growth}. In the next step, cells adjacent to \code{seed} cells
meeting the conditions of the argument \code{cond.isol} are classified as
\code{isolator} cells. As for \code{seed} cells, the algorithm will
continue looking for \code{isolator} cells as long as among the neighbors
of the newly classified \code{isolator} cells there are cells that meet the
conditions of \code{cond.isol}. When a cell is classified either as
\code{seed} or as \code{isolator}, then it is ignored in all successive
iterations of the algorithm. The \code{cond.seed}, \code{cond.growth},
\code{cond.isol} process is repeated until all cells are classified either
as \code{seed} or as \code{isolator}.

The evaluation of \code{cond.growth} and \code{cond.isol} follows a node
structure. Let us consider \code{cond.growth} as an example and refer to
'the conditions of the \code{cond.growth} argument' simply as \code{cond}.
At \code{level_0} there is a single node, a cell previously classified as
\code{seed}. Each cell adjacent to the node in \code{level_0} that evaluate
positively to \code{cond} represents a node at \code{level_1}. Suppose that
at \code{level_1} there are one or more nodes. The algorithm then considers
the first of these nodes and looks for neighbor cells evaluating positively
to \code{cond}. If one or more cells do, then the first node of
\code{level_1} is set as \code{referenceNode} for \code{level_2}. The
algorithm then evaluates if one or more cells adjacent to the first node in
\code{level_2} evaluate positively to \code{cond}. If any does, then the
first node of \code{level_2} is set as \code{referenceNode} for
\code{level_3}. The algorithm continues in this way until \code{level_n}
where none of the adjacent cells evaluate positively to \code{cond}. At
this point the algorithm considers cells adjacent to the second node at
\code{level_n-1}. If any cell has a positive evaluation, then second node
in \code{level_n-1} is set as \code{referenceNode} for \code{level_n} and
the algorithm continues as described above. On the contrary, if none of the
cells evaluate positively to \code{cond}, the algorithm will remain at at
\code{level_n-1} and will consider the next node. If none of the nodes at
\code{level_n-1} has any neighboring cell evaluating positively to
\code{cond}, then the algorithm will move down to \code{level_n-2}. The
evaluation of \code{cond.growth} will stop once the algorithm returns to
\code{level_0}.

This implementation allows to track back to \code{level_0} all the
connected cells having a positive evaluation. When conditions relative to
the focal cell are considered (see \code{\link{conditions}}), the arguments
\code{lag.growth} and \code{lag.isol} determine to which
\code{referenceNode} newly evaluated cells have to be compared to. A lag of
\code{1} indicates that the conditions at \code{level_n} have to be
evaluated considering the \code{referenceNode} at \code{level_n-1}. A lag
set as \code{Inf} indicates that at any level the conditions are evaluated
considering the initial node cell at \code{level_0}. If the lag is greater
than the level at which the evaluation occurs, then the conditions are
evaluated considering the initial node cell at \code{level_0} (e.g.,
\code{level_1}, \code{lag = 2}).
}
\seealso{
\code{\link[=conditions]{conditions()}}, \code{\link[=attTbl]{attTbl()}}, \code{\link[=ngbList]{ngbList()}}
}
