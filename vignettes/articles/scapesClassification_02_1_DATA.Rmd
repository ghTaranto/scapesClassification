---
title: "Format input data"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Format input data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width = "100%", echo = TRUE)
```

## Study case and input data
Our study area is located in the 'Triangle' of the Azores (NE Atlantic), around the islands of Faial, Pico and SÃ£o Jorge ([Figure 1](#figure1)). Geomorphic management units (GMUs) will be identified using a `SpatRaster`([`terra package`](https://rspatial.org/spatial-terra/4-rasterdata.html#spatrast)) of six layers that includes bathymetry, bathymetric derivatives ([Walbridge et al., 2018](https://www.mdpi.com/2076-3263/8/3/94/htm)) and the geomorphons of the area ([Jasiewicz and Stepinski, 2013](https://www.sciencedirect.com/science/article/pii/S0169555X12005028#!)):
  
* **Bathymetry:** depth values;
* **Local BPI:** bathymetric position index (BPI) computed with an outer radius of 10px (ca. 5 km);
* **Regional BPI:** bathymetric position index (BPI) computed with an outer radius of 40px (ca. 20 km);
* **Slope:** slope values;
* **SD bathymetry:** standard deviation of bathymetric values computed on a 9x9 window;
* **Geomorphons:** identify basic morphological terrain types.

We will start by loading the required libraries and data into the workspace:
```{r loadLD, message=FALSE, warning=FALSE, collapse = TRUE}
# LOAD LIBRARIES
library(scapesClassification)
library(terra)

# LOAD DATA
grd <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T)
grd <- grd[grepl("\\.grd", grd)]
grd <- grd[!grepl("hillshade", grd)]
rstack <- rast(grd)
```

```{r hillShade, message=FALSE, include=FALSE}
# hillShade
hs <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T)
hs <- rast(hs[grepl("hillshade\\.grd", hs)])
```

```{r loadMapView, message=FALSE, include=FALSE}
library(mapview)
library(leaflet)
library(leafem)

# set gerenal options 
mapviewOptions(basemaps = c("Esri.OceanBasemap", "OpenStreetMap"), na.color = "grey88", homebutton = FALSE, 
               query.position = "bottomright", legend.opacity = 0.9)

# set palettes
palRYB <- c("#2892c7", "#fafa64", "#e81014")
palYGB <- c("#ffff80" ,"#3dba65", "#0d1178")
palBYR <- c("#4575b5", "#ffffbf", "#d62f27")
gm_col <- c("grey70", "#380000", "#c80000", "#ff5014", "#fad23c", "#ffff3c", "#b4e614", "#3cfa96", "#0000ff", "#000038")
```

<a id="figure1"></a>
We can plot the raster stack as an interactive map using the R packages [`mapview`](https://r-spatial.github.io/mapview/) and [`leaflet`](https://rstudio.github.io/leaflet/): 

_Note that raster of class `SpatRaster` (package `terra`) are not yet supported in interactive maps, therefore, we will always convert raster objects to the class `RasterLayer` (package `raster`) before plotting._

```{r plotRSTACK, message=FALSE, warning=FALSE, echo=FALSE}
m <- mapview(raster::raster(rstack[[1]]), layer.name = c("Bathymetry (m)"), col.regions = palRYB) +
  mapview(raster::raster(rstack[[3]]), layer.name = c("Local BPI"), col.regions = palBYR, hide = TRUE) + 
  mapview(raster::raster(rstack[[4]]), layer.name = c("Regional BPI"), col.regions = palBYR, hide = TRUE) +
  mapview(raster::raster(rstack[[6]]), layer.name = c("Slope (deg)"), col.regions = palYGB, hide = TRUE) + 
  mapview(raster::raster(rstack[[5]]), layer.name = c("SD Bathymetry (9x9)"), col.regions = palYGB, hide = TRUE) + 
  mapview(as.factor(raster::raster(rstack[[2]])), layer.name = c("Geomorphons"), method = "ngb", col.regions = gm_col, at=0:10)

m@map %>% 
  hideGroup(c("Local BPI", "Regional BPI", "Slope (deg)", "SD Bathymetry (9x9)", "Geomorphons")) %>% 
  setView(lng = -28.55, lat = 38.45, zoom = 8) %>%
  addLayersControl(baseGroups = c("Esri.OceanBasemap", "OpenStreetMap"),
                   overlayGroups = c("Bathymetry (m)", "Local BPI", "Regional BPI", "Slope (deg)", "SD Bathymetry (9x9)", "Geomorphons"),
                   position = "topleft",
                   options = layersControlOptions(collapsed = FALSE))
```
<div style="line-height: 0.9em; margin-bottom: 1.5em;"><span class="legend">**FIGURE 1 -** Raster layers used for the classification of Geomorphic Management Units (GMUs). The geomorphon classes correspond to (1) flat, (2) summit, (3) ridge, (4) shoulder, (5) spur, (6) slope, (7) hollow, (8) footslope, (9) valley and (10) depression.</span></div>

## Format input data
The classification process in `scapesClassification` begins with the computation of two elements (see [Format inputs](scapesClassification_01_1_FormatInputs.html)):

__Attribute table:__ the raster object converted into a `data.frame`. Attribute tables include only raster cells having no missing values. Function `attTbl()`.
```{r attTbl, message=FALSE, warning=FALSE, collapse = TRUE}
# COMPUTE ATTRIBUTE TABLE
atbl <- attTbl(rstack, var_names = c("bathymetry", "gmorph", "local_bpi", "regional_bpi", "sd_bat", "slope"))

# VIEW THE TOP 3 ROWS OF `atbl`
# Each row corresponds to a raster cell as indicated in the column `atbl$Cell`

head(atbl, 3) 
```

__List of neighborhoods:__ the neighborhoods of every raster cell included in the attribute table. Function `ngbList()`. 
```{r ngbList, message=FALSE, warning=FALSE, collapse = TRUE}
# COMPUTE NEIGHBORHOOD LIST
nbs <- ngbList(rstack, rNumb = TRUE, attTbl = atbl) # the neighbors are identified by row numbers (see ?ngbList)

# VIEW THE TOP ELEMENT OF `nbs`
nbs[1]

# nbs[1] reads as:
# the cell in row $`1` of `atbl` has 
# cells in `atbl` rows 2, 291 and 292 as neighbors
```
