---
title: "Geomorphic Management Units (GMUs)"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width = "100%", echo = TRUE)
```

The following is an example of how to use _scapesClassification_ to classify marine seafloor structures, hereafter referred to as geomorphic management units (GMUs). Our study area is located in the 'Triangle' of the Azores (NE Atlantic), around the islands of Faial, Pico and São Jorge. GMUs will be identified using a `RasterStack` of six layers that includes bathymetry, bathymetric derivatives ([Walbridge et al., 2018](https://www.mdpi.com/2076-3263/8/3/94/htm)) and the geomorphons of the area ([Jasiewicz and Stepinski, 2013](https://www.sciencedirect.com/science/article/pii/S0169555X12005028#!)):
  
* **Bathymetry:** depth values;
* **Local BPI:** benthic position index (BPI) computed with an outer radius of 10px (ca. 5 km);
* **Regional BPI:** benthic position index (BPI) computed with an outer radius of 40px (ca. 20 km);
* **Slope:** slope values;
* **SD bathymetry:** standard deviation of bathymetric values computed on a 9x9 window;
* **Geomorphons:** identify basic morphological terrain types.

# Load libraries and data
We will start by loading the required libraries and data into the workspace:
```{r loadLD, message=FALSE, warning=FALSE, collapse = TRUE}
# LOAD LIBRARIES
library(raster)
library(scapesClassification)

# LOAD DATA
grd <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T)
grd <- grd[grepl("\\.grd", grd)]
grd <- grd[!grepl("hillshade", grd)]
rstack <- stack(grd)
```

```{r hillShade, message=FALSE, include=FALSE}
# hillShade
hs <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T)
hs <- raster(hs[grepl("hillshade\\.grd", hs)])
```

```{r loadMapView, message=FALSE, include=FALSE}
library(mapview)
library(leaflet)
library(leafem)

# set gerenal options 
mapviewOptions(basemaps = c("Esri.OceanBasemap", "OpenStreetMap"), na.color = "grey88", homebutton = FALSE, 
               query.position = "bottomright", legend.opacity = 0.9)

# set palettes
palRYB <- c("#2892c7", "#fafa64", "#e81014")
palYGB <- c("#ffff80" ,"#3dba65", "#0d1178")
palBYR <- c("#4575b5", "#ffffbf", "#d62f27")
gm_col <- c("grey70", "#380000", "#c80000", "#ff5014", "#fad23c", "#ffff3c", "#b4e614", "#3cfa96", "#0000ff", "#000038")
```

<a id="rstack"></a>
We can plot the raster stack as an interactive map using the R packages `mapview` and `leaflet`: 
```{r plotRSTACK, message=FALSE, warning=FALSE, echo=FALSE}
# plotRSTACK
m <- mapview(rstack[[1]], layer.name = c("Bathymetry (m)"), col.regions = palRYB) +
  mapview(rstack[[3]], layer.name = c("Local BPI"), col.regions = palBYR, hide = TRUE) + 
  mapview(rstack[[4]], layer.name = c("Regional BPI"), col.regions = palBYR, hide = TRUE) +
  mapview(rstack[[6]], layer.name = c("Slope (deg)"), col.regions = palYGB, hide = TRUE) + 
  mapview(rstack[[5]], layer.name = c("SD Bathymetry (9x9)"), col.regions = palYGB, hide = TRUE) + 
  mapview(as.factor(rstack[[2]]), layer.name = c("Geomorphons"), method = "ngb", col.regions = gm_col, at=0:10)
  
m@map %>% 
  hideGroup(c("Local BPI", "Regional BPI", "Slope (deg)", "SD Bathymetry (9x9)", "Geomorphons")) %>% 
  setView(lng = -28.55, lat = 38.45, zoom = 8) %>%
  addLayersControl(baseGroups = c("Esri.OceanBasemap", "OpenStreetMap"),
                   overlayGroups = c("Bathymetry (m)", "Local BPI", "Regional BPI", "Slope (deg)", "SD Bathymetry (9x9)", "Geomorphons"),
                   position = "topleft",
                   options = layersControlOptions(collapsed = FALSE))
```
_FIGURE 1 - Raster layers used for the classification of Geomorphic Management Units (GMUs). The geomorphon classes correspond to (1) flat, (2) summit, (3) ridge, (4) shoulder, (5) spur, (6) slope, (7) hollow, (8) footslope, (9) valley and (10) depression._


# Format inputs
The classification process in _scapesClassification_ begins with the computation of two objects:

<a id="atbl"></a>

__Attribute table:__ the raster object converted into a `data.frame`. Attribute tables include only raster cells with complete cases (i.e., having no missing values). Function `attTbl` (see `?attTbl`).
```{r attTbl, message=FALSE, warning=FALSE, collapse = TRUE}
# COMPUTE ATTRIBUTE TABLE
atbl <- attTbl(rstack, var_names = c("bathymetry", "gmorph", "local_bpi", "regional_bpi", "sd_bat", "slope"))

# VIEW THE TOP 3 ROWS OF `atbl`
# Each row corresponds to a raster cell as indicated in atbl$Cell

head(atbl, 3) 
```

__Neighborhood list:__ the `list` of neighbors (with some exceptions, the 8-cells adjacent to a central cell) of every non-NA cell included in the attribute table. Function `ngbList` (see `?ngbList`) 
```{r ngbList, message=FALSE, warning=FALSE, collapse = TRUE}
# COMPUTE NEIGHBORHOOD LIST
nbs <- ngbList(rstack, rNumb = TRUE, attTbl = atbl) # neighbors are identified by their row number in the attribute table

# VIEW THE TOP ELEMENT OF `nbs`
nbs[1]

# nbs[1] reads as:
# the cell in row $`1` of `atbl` has 
# cells of rows 2, 291 and 292 as neighbors
```


# Island Shelf Unit (ISU)
We can start our GMUs classification with the island shelf unit (ISU). The ISU comprises two main elements: _(i)_ ___island shelves___ (i.e., relatively flat areas surrounding islands) and _(ii)_ ___slopes___ (i.e., areas that connect island shelves to the seafloor).


## Identify anchor cells
Anchor cells are raster cells that can be easily assigned to a class because of some distinctive attribute(s). For example, cells ___'adjacent to an island'___ by definition are _'island shelf cells'_. We can identify this initial set of _'ISU-cells'_ using the functions:

* __`anchor.svo`:__ returns a vector of cell numbers extracted at the locations of a spatial vector object. In this example, _'land cells'_ are defined as: _(i)_ raster cells extracted at island locations that are not complete cases (arg. `ONLY_NA = T`); _(ii)_ cells adjacent to cells of point (i) that are not complete cases either (arg. `fill_NAs = T`) ([Figure 2](#figure2)). 

```{r ISU_land, message=FALSE, warning=FALSE, collapse = TRUE}
# ISLAND SHAPEFILE PATH
shp <- system.file("extdata", "Azores.shp", package = "scapesClassification")

# EXTRACT LAND POSITIONS
anchorLAND <- anchor.svo(rstack              = rstack, 
                         spatial_vector_name = shp, 
                         only_NAs            = TRUE, 
                         fill_NAs            = TRUE, 
                         plot                = FALSE)
```

* __`anchor.cell`:__ converts a vector of cell numbers into a **classification vector**. In this example, all cells adjacent to _'land cells'_ (arg. `class2cell = F` and `class2nbs = T`) will be considered as _'anchor cells'_ ([Figure 2](#figure2)).

<a id="ISU_anchor"></a>
```{r ISU_anchor, message=FALSE, warning=FALSE, collapse = TRUE}
# COMPUTE ANCHOR CELLS
anchorCELL <- anchor.cell(attTbl     = atbl, 
                          rstack     = rstack, 
                          anchor     = anchorLAND, 
                          class      = 1, # ANCHOR CELL CLASS = 1
                          class2cell = FALSE,
                          class2nbs  = TRUE,
                          plot       = FALSE) 
```

Classification vectors map raster cells to numeric classes (or to NA-values if no class is attributed). The n^th^ element of a classification vector corresponds to the raster cell contained in the n^th^ row of an attribute table.
```{r cVect, message=FALSE, warning=FALSE, collapse = TRUE}
# CLASSIFICATION VECTOR
unique(anchorCELL) 

# anchorCELL == 1,  ISU anchor cells
# anchorCELL == NA, unclassified cells

length(anchorCELL) == NROW(atbl)
```

Classification vectors can be converted into a raster, plotted and saved using the function `cv.2.rast`. However, here we will present classification outputs as interactive maps:
<a id="figure2"></a>
```{r ISU_anchor_map, message=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
# ISU_anchor
island <- rgdal::readOGR(dsn = shp, verbose = F)
island <- sp::spTransform(island, raster::crs(rstack))
island$BASE[c(5,4,49)] <- c("Pico", "Faial", "Sao Jorge") # mouseover labels

rL  <- rstack[[1]]; rL[]  <- NA; rL[anchorLAND] <- 1
rAC <- rstack[[1]]; rAC[] <- NA; rAC[atbl$Cell] <- anchorCELL
rCC <- rstack[[1]]; rCC[] <- NA; rCC[atbl$Cell] <- 1

# convert to polygon so that mapview projection does not affect visualization
rL  <- rasterToPolygons(rL, dissolve = TRUE)
rAC <- rasterToPolygons(rAC, dissolve = TRUE)
rCC <- rasterToPolygons(rCC, dissolve = TRUE)

# add a column so that mapview legend reads layer.name and not values
rL$dummy  <- 1
rAC$dummy <- 1
rCC$dummy <- 1

m <- 
  mapview(rAC, alpha.regions = 1, 
             col.regions = "orange", layer.name = "Anchor cell", popup = NULL, label = "Anchor Cell") + 
  mapview(rL, alpha.regions = 1, 
          col.regions = "black", layer.name = "Land cell", popup = NULL, label = "Land cell") + 
  mapview(rCC, alpha.regions = 0.5, 
          col.regions = "red", layer.name = "Complete cases", popup = NULL, label = "Complete cases") +
  mapview(island, alpha.region = 0, col.regions = "cyan", color = "cyan", lwd = 2, label = "BASE", 
          layer.name = "Island shapefile", popup = NULL)

m@map %>% 
  hideGroup(c("Complete cases", "Island shapefile")) %>% 
  setView(lng = -28.35, lat = 38.59, zoom = 10) %>%
  addLayersControl(baseGroups = c("OpenStreetMap"),
                   overlayGroups = c("Anchor cell", "Land cell", "Complete cases", "Island shapefile"),
                   position = "topleft",
                   options = layersControlOptions(collapsed = TRUE))
```
_FIGURE 2 - **Anchor cell:** raster cells adjacent to a 'land cell'. **Land cell**: raster cells extracted at the locations of the 'island shapefile' that are not complete cases and all adjacent cells that are not complete cases either. **Complete cases**: raster cells within [rstack](#rstack) having no missing values; note that no overlap exists between "land cell" and "complete cases". **Island shapefile**: the shapefile of Faial, Pico and São Jorge Islands._


## ISU - Island shelf cells
In the previous section we identified the portion of ‘island shelves’ that is adjacent to an island. Another useful property is that ‘island shelves’ ___tend to be flat___. This property is shared by several classes (e.g., flat tops or abyssal plains), but it can still define ‘island shelves’ if considered in the context of class contiguity and continuity. 

We will use the following set of rules to identify the _'flat cells'_ of ‘island shelves’: 

a. We assume that a cell is flat if its `slope < 5º`;
b. Flat cells adjacent to _'island shelf cells'_ are classified as _'island shelf'_ (_class contiguity_);
c. As long as new _'island shelf cells'_ are identified, rule b can be evaluated for new adjacent cells (_class continuity_);

This set of rules can be evaluated using the function: 

* __`cond.4.nofn`:__ Evaluate conditions for cells neighboring specific classes (more information about this function is available via `?cond.4.nofn` or at section XXX). In this case, the function identifies ISU _'flat cells'_ ([Figure 3](#figure3)) based on the above set of rules.

```{r ISU_flat, message=FALSE, warning=FALSE, collapse = TRUE}
# ISU SHELF CELLS (FLAT CELLS)
flatCELLS <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                         
                         # anchor cells classification vector
                         classVector = anchorCELL,  
                         
                         # flat cell class 
                         class = 2,
                         
                         # evaluate cells adjacent to anchor cells (class=1) or flat cells (class=2)
                         nbs_of = c(1, 2), 
                         
                         # condition string (slope refers to the column `slope` of `atbl`)
                         conditions = "slope <= 5", 
                         
                         # a cell is classified if conditions are true AND if 20% of its neighboring cells belongs to one of the classes of the argument `nbs_of`
                         min.border = 0.2)
```

Once _'flat cells'_ have been identified, we will assume that raster cells surrounded by _'island shelf cells'_ are also _'island shelf cells'_ (_'hole cell'_, [Figure 3](#figure3)). We define a cell as surrounded if 60% of its neighbors belong to an _'island shelf'_ class: 
```{r ISU_hole, message=FALSE, warning=FALSE, collapse = TRUE}
# ISU SHELF CELLS (FILL CLASSIFICATION HOLES)
holeCELLS <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                         classVector = flatCELLS, 
                         class = 3,           # hole cell class
                         nbs_of = c(1, 2, 3),
                         conditions = "TRUE", # conditions are always true
                         min.border = 0.6)    # a cell is classified if 60% of its neighboring cells belongs to one of the classes of the argument `nbs_of`
```

We can visualize the three types of _'island shelf cells'_: 
<a id="figure3"></a>
```{r ISU_shelf_map, message=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
rSC1 <- rstack[[1]]; rSC1[] <- NA; rSC1[ atbl$Cell[ holeCELLS == 2 ] ] <- 1
rSC2 <- rstack[[1]]; rSC2[] <- NA; rSC2[ atbl$Cell[ holeCELLS == 3 ] ] <- 1

rSC1 <- rasterToPolygons(rSC1, dissolve = TRUE)
rSC2 <- rasterToPolygons(rSC2, dissolve = TRUE)

rSC1$dummy <- 1
rSC2$dummy <- 1

m <-
  mapview(rAC, alpha.regions = 0.8, 
          col.regions = "orange", layer.name = "Anchor cell", popup = NULL, label = "ISU shelf cell (anchor cell)") + 
  mapview(rSC1, alpha.regions = 0.8, 
          col.regions = "#FFD700", layer.name = "Flat cell", popup = NULL, label = "ISU shelf cell (flat cell)") + 
  mapview(rSC2, alpha.regions = 0.8, 
          col.regions = "#A0522D", layer.name = "Hole cell", popup = NULL, label = "ISU shelf cell (hole cell)") + 
  mapview(rstack[[6]], layer.name = "SLOPE (deg)", col.regions = palYGB)

m@map %>% 
  hideGroup(c("SLOPE (deg)")) %>% 
  setView(lng = -28.40, lat = 38.55, zoom = 9) %>%
  addLayersControl(overlayGroups = c("Anchor cell", "Flat cell", "Hole cell", "SLOPE (deg)"),
                   position = "topleft",
                   options = layersControlOptions(collapsed = FALSE))  %>%
  htmlwidgets::onRender("
        function() {
            $('.leaflet-control-layers-overlays').prepend('<label style=\"text-align:left\">Island Shelf Cells: </label>');
        }
    ")
```
_FIGURE 3 - **Anchor cell:** raster cells adjacent to a 'land cell'. **Flat cell:** raster cells with slopes < 5º respecting class contiguity and continuity with island shelf cells. **Hole cell:** raster cell whose 60% of neighboruring cells are classified as island shelf cells. **Slope:** slope values. Because of reprojection (resampling) displayed and original values might be slightly different._


### Classification vectors

Note that each time a classification vector is provided to a function it is updated with the new cells that were classified and that the last one computed (`holeCELLS`) includes all the previous classificaiton steps:
```{r classVect_exm, message=FALSE, warning=FALSE, collapse = TRUE}
# CLASSVECTORS

# anchorCELL - initial class vector of anchor cells
unique(anchorCELL)

# flatCELLS - anchorCELL updated with flat cells
unique(flatCELLS)

# holeCELLS - flatCELLS updated with hole cells
unique(holeCELLS)

# holeCELLS == 1,  ISU anchor cells
# holeCELLS == 2,  ISU flat cells
# holeCELLS == 3,  ISU hole cells
# holeCELLS == NA, Non-ISU cells
```


## ISU - Slope cells {#ISU_slope}
We can identify _'slope cells'_ using three sets of conditions. All sets of conditions will take into account class contiguity and continuity to evaluate conditions (i.e., conditions are evaluated only for cells adjacent either to _'island shelf cells'_ or to _'slope cells'_ and the evaluation continues as long as new _'slope cells'_ are identified). 

___Slope1 cell.___ In the first set of conditions we consider that in regions adjacent to island shelves, _'slope cells'_ tend to have positive BPI values (`regional_bpi > 100`) (_'Slope1 cell'_, [Figure 4](#figure4)). 
```{r Slope1, message=FALSE, message=FALSE, warning=FALSE}
slope1 <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                      classVector = holeCELLS, 
                      nbs_of = c(1,2,3,4), 
                      conditions = "regional_bpi > 100",
                      class = 4,
                      min.border = 0.2)
```

___Slope2 cell.___ In the second set of conditions we consider that small ridges connected to _'ISU cells'_ can be considered as part of the _'ISU slopes'_. Small ridges can be identified by high local BPI values (`local_bpi{} > 100`) (_'Slope2 cell'_, Figure 4). Note that we use the tag `{}` after the variable `local_bpi` and the argument `fn_perc = 0.4`. The tag `{}` flags an _absolute focal neighborhood conditions_, and `fn_perc = 0.4` states that the focal cell is classified only if conditions are true for at least 40% of the cells included in the focal neighborhood. 
```{r Slope2, message=FALSE, message=FALSE, warning=FALSE}
slope2 <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                      classVector = slope1, 
                      nbs_of = c(1,2,3,4,5), 
                      conditions = "local_bpi{} > 100", 
                      class = 5,
                      fn_perc = 0.4,
                      min.border = 0.2)
```

___Slope3 cell.___ In the third set of conditions we consider that even cells having negative BPI values can be part of _'ISU slopes'_. We can assume that as long as there is an high bathymetric variation around a raster cell connected to a slope the seafloor has not been reached. We will set this condition using again the `{}` tag (`sd_bat{} > 150`), but we will change `fn_perc = 1` (_'Slope3 cell'_, [Figure 4](#figure4)).
```{r Slope3, message=FALSE, message=FALSE, warning=FALSE}
slope3 <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                      classVector = slope2, 
                      nbs_of = c(1,2,3,4,5,6), 
                      conditions = "sd_bat{} > 150", 
                      class = 6,
                      fn_perc = 1,
                      min.border = 0.2)
```

<a id="figure4"></a>
We can plot the result of the _'ISU slope'_ classification:
```{r ISU_slope_map, message=FALSE, warning=FALSE, echo=FALSE}
rSL1 <- rstack[[1]]; rSL1[] <- NA; rSL1[ atbl$Cell[ slope3 == 4 ] ] <- 1
rSL2 <- rstack[[1]]; rSL2[] <- NA; rSL2[ atbl$Cell[ slope3 == 5 ] ] <- 1
rSL3 <- rstack[[1]]; rSL3[] <- NA; rSL3[ atbl$Cell[ slope3 == 6 ] ] <- 1

rSL1 <- rasterToPolygons(rSL1, dissolve = TRUE)
rSL2 <- rasterToPolygons(rSL2, dissolve = TRUE)
rSL3 <- rasterToPolygons(rSL3, dissolve = TRUE)

rSL1$dummy <- 1
rSL2$dummy <- 1
rSL3$dummy <- 1

mapviewOptions(basemaps = c("Esri.OceanBasemap", "OpenStreetMap"))
m <-
  mapview(rSL1, alpha.regions = 0.8, col.regions = "#BFB5AF", layer.name = "Slope1 cell", popup = NULL, 
        label = "(regional_bpi > 100 & bathymetry{} > bathymetry) | regional_bpi > 300") +
  
  mapview(rSL2, alpha.regions = 0.8, layer.name = "Slope2 cell", col.regions = "#582C4D", popup = NULL, 
          label = "local_bpi{} > 100") +
  
  mapview(rSL3, alpha.regions = 0.8, layer.name = "Slope3 cell", col.regions = "black", popup = NULL, 
          label = "local_bpi{} > 100") +
  
  mapview(rAC, alpha.regions = 0.8, 
          col.regions = "orange", layer.name = "Anchor cell", popup = NULL, label = "ISU shelf cell (anchor cell)") + 
  
  mapview(rSC1, alpha.regions = 0.8, 
          col.regions = "#FFD700", layer.name = "Flat cell", popup = NULL, label = "ISU shelf cell (flat cell)") + 
  
  mapview(rSC2, alpha.regions = 0.8, 
          col.regions = "#A0522D", layer.name = "Hole cell", popup = NULL, label = "ISU shelf cell (hole cell)") + 
  
  mapview(rstack[["regional_bpi_exm"]], layer.name = "Regional_BPI", col.regions = palBYR, legend = FALSE, alpha.regions = 0.3) + 
  
  mapview(rstack[["local_bpi_exm"]], layer.name = "Local_BPI", col.regions = palBYR, legend = FALSE, alpha.regions = 0.2) + 
 
  mapview(rstack[["sd_bat_exm"]], layer.name = "SD_bathymetry", col.regions = palYGB, legend = FALSE, alpha.regions = 0.1)

m@map %>% 
  hideGroup(c("Anchor cell", "Flat cell", "Hole cell")) %>% 
  setView(lng = -28.43, lat = 38.45, zoom = 9) %>%
  addLayersControl(overlayGroups = c("Slope1 cell", "Slope2 cell", "Slope3 cell",
                                     "Anchor cell", "Flat cell", "Hole cell"),
                   position = "topleft",
                   options = layersControlOptions(collapsed = FALSE))
```
_FIGURE 4 - Island shelf units (ISUs) identified by slope and island shelf cells. In background are provided BPI and SD bathymetry values; because of reprojection displayed and original values are slightly different._
