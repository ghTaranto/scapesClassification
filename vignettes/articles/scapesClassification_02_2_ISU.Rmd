---
title: "2.Island shelf unit (ISU)"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{2.Island shelf unit (ISU)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width = "100%", echo = TRUE)
```

We can start our GMUs classification with the island shelf unit (ISU). The ISU comprises two main elements: _(i)_ __island shelves__ (i.e., relatively flat areas surrounding islands) and _(ii_) __slopes__ (i.e., areas that connect island shelves to the seafloor).

## 2.1 Load data and libraries

First, We will load the required libraries and data into the workspace. These steps were explained in the [previous article](scapesClassification_02_1_DATA.html): 

```{r loadLD, message=FALSE, warning=FALSE, collapse = TRUE, class.source = 'fold-hide'}
# LOAD LIBRARIES
library(raster)
library(scapesClassification)

# LOAD DATA
grd <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T)
grd <- grd[grepl("\\.grd", grd)]
grd <- grd[!grepl("hillshade", grd)]
rstack <- stack(grd)

# COMPUTE ATTRIBUTE TABLE
atbl <- attTbl(rstack, var_names = c("bathymetry", "gmorph", "local_bpi", "regional_bpi", "sd_bat", "slope"))

# COMPUTE NEIGHBORHOOD LIST
nbs <- ngbList(rstack, rNumb = TRUE, attTbl = atbl) # neighbors are identified by their row number in the attribute table
```

```{r hillShade, message=FALSE, include=FALSE}
# hillShade
hs <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T)
hs <- raster(hs[grepl("hillshade\\.grd", hs)])

library(mapview)
library(leaflet)
library(leafem)

# set gerenal options 
mapviewOptions(basemaps = c("Esri.OceanBasemap", "OpenStreetMap"), na.color = "grey88", homebutton = FALSE, 
               query.position = "bottomright", legend.opacity = 0.9)

# set palettes
palRYB <- c("#2892c7", "#fafa64", "#e81014")
palYGB <- c("#ffff80" ,"#3dba65", "#0d1178")
palBYR <- c("#4575b5", "#ffffbf", "#d62f27")
gm_col <- c("grey70", "#380000", "#c80000", "#ff5014", "#fad23c", "#ffff3c", "#b4e614", "#3cfa96", "#0000ff", "#000038")
```

## 2.2 ISU - Anchor cells
Anchor cells are raster cells that can be easily assigned to a class because of some distinctive attribute(s). For example, cells ___'adjacent to an island'___ by definition are _'island shelf cells'_. We can derive this initial set of _'ISU-anchor cells'_ using the functions:

__`anchor.svo()`:__ returns a vector of cell numbers extracted at the locations of a spatial vector object. In this example, _'land cells'_ are defined as: _(i)_ raster cells extracted at island locations that are not complete cases (arg. `ONLY_NA = T`); _(ii)_ cells adjacent to cells of point _(i)_ that are not complete cases either (arg. `fill_NAs = T`) ([Figure 1](#figure1)). 

```{r ISU_land, message=FALSE, warning=FALSE, collapse = TRUE}
# ISLAND SHAPEFILE PATH
shp <- system.file("extdata", "Azores.shp", package = "scapesClassification")

# EXTRACT LAND POSITIONS
anchorLAND <- anchor.svo(rstack              = rstack, 
                         spatial_vector_name = shp, 
                         only_NAs            = TRUE, 
                         fill_NAs            = TRUE, 
                         plot                = FALSE)
```

__`anchor.cell()`:__ converts a vector of cell numbers into a **class vector**. In this example, all cells adjacent to _'land cells'_ (arg. `class2cell = F` and `class2nbs = T`) will be considered as _'ISU-anchor cells'_ ([Figure 1](#figure1)).

<a id="ISU_anchor"></a>
```{r ISU_anchor, message=FALSE, warning=FALSE, collapse = TRUE}
# COMPUTE ANCHOR CELLS
anchorCELL <- anchor.cell(attTbl     = atbl, 
                          rstack     = rstack, 
                          anchor     = anchorLAND, 
                          class      = 1, # ANCHOR CELL CLASS = 1
                          class2cell = FALSE,
                          class2nbs  = TRUE,
                          plot       = FALSE) 
```

Class vectors map raster cells to numeric classes (or to NA-values if no class is attributed). The n^th^ element of a class vector corresponds to the raster cell contained in the n^th^ row of an attribute table.

```{r cVect, message=FALSE, warning=FALSE, collapse = TRUE}
# CLASS VECTOR
unique(anchorCELL) 

# anchorCELL == 1,  ISU anchor cells
# anchorCELL == NA, unclassified cells

length(anchorCELL) == NROW(atbl)
```

Class vectors can be converted into a raster, plotted and saved using the function `cv.2.rast()`. However, here we will present classification outputs as interactive maps.
<a id="figure1"></a>
```{r ISU_anchor_map, message=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
# ISU_anchor
island <- rgdal::readOGR(dsn = shp, verbose = F)
island <- sp::spTransform(island, raster::crs(rstack))
island$BASE[c(5,4,49)] <- c("Pico", "Faial", "Sao Jorge") # mouseover labels

rL  <- rstack[[1]]; rL[]  <- NA; rL[anchorLAND] <- 1
rAC <- rstack[[1]]; rAC[] <- NA; rAC[atbl$Cell] <- anchorCELL
rCC <- rstack[[1]]; rCC[] <- NA; rCC[atbl$Cell] <- 1

# convert to polygon so that mapview projection does not affect visualization
rL  <- rasterToPolygons(rL, dissolve = TRUE)
rAC <- rasterToPolygons(rAC, dissolve = TRUE)
rCC <- rasterToPolygons(rCC, dissolve = TRUE)

# add a column so that mapview legend reads layer.name and not values
rL$dummy  <- 1
rAC$dummy <- 1
rCC$dummy <- 1

m <- 
  mapview(rAC, alpha.regions = 1, 
             col.regions = "orange", layer.name = "Anchor cell", popup = NULL, label = "Anchor Cell") + 
  mapview(rL, alpha.regions = 1, 
          col.regions = "black", layer.name = "Land cell", popup = NULL, label = "Land cell") + 
  mapview(rCC, alpha.regions = 0.5, 
          col.regions = "red", layer.name = "Complete cases", popup = NULL, label = "Complete cases") +
  mapview(island, alpha.region = 0, col.regions = "cyan", color = "cyan", lwd = 2, label = "BASE", 
          layer.name = "Island shapefile", popup = NULL)

m@map %>% 
  hideGroup(c("Complete cases", "Island shapefile")) %>% 
  setView(lng = -28.35, lat = 38.59, zoom = 10) %>%
  addLayersControl(baseGroups = c("OpenStreetMap", "Esri.OceanBasemap"),
                   overlayGroups = c("Anchor cell", "Land cell", "Complete cases", "Island shapefile"),
                   position = "topleft",
                   options = layersControlOptions(collapsed = TRUE))
```
<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 1 -** **Anchor cell:** raster cells adjacent to a 'land cell'. **Land cell**: raster cells extracted at the locations of the 'island shapefile' that are not complete cases and all adjacent cells that are not complete cases either. **Complete cases**: raster cells having no missing values in no layer of the stack ([Figure 1](#figure1)); note that no overlap exists between "land cell" and "complete cases". **Island shapefile**: the shapefile of Faial, Pico and São Jorge Islands.</span></div>


## 2.3 ISU - Island shelf cells
In the previous section we identified the portion of ‘island shelves’ that is adjacent to an island. Another useful property is that ‘island shelves’ ___tend to be flat___. This property is shared by several classes (e.g., flat tops or abyssal plains), but it can still define ‘island shelves’ if considered in the context of class contiguity and continuity. 

We will use the following set of rules to identify the _'island shelf cells'_: 

a. We assume that a cell is flat if its `slope < 5º`;
b. Flat cells adjacent to _'island shelf cells'_ are classified as _'island shelf'_ (_class contiguity_);
c. As long as new _'island shelf cells'_ are identified, rule b can be evaluated for new adjacent cells (_class continuity_);

This set of rules can be evaluated using the function: 

__`cond.4.nofn()`:__ Evaluate conditions for cells neighboring specific classes. In this case, the function identifies the _'flat cells'_ of island shelves based on the above set of rules ([Figure 2](#figure2)).

```{r ISU_flat, message=FALSE, warning=FALSE, collapse = TRUE}
# ISU SHELF CELLS (FLAT CELLS)
flatCELLS <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                         
                         # `anchorCELL` class vector
                         classVector = anchorCELL,  
                         
                         # flat cell class 
                         class = 2,
                         
                         # evaluate cells adjacent to anchor cells (class=1) or flat cells (class=2)
                         nbs_of = c(1, 2), 
                         
                         # condition string (slope refers to the column `slope` of `atbl`)
                         conditions = "slope <= 5", 
                         
                         # a cell is classified if conditions are true AND if at least 20% of its neighboring cells belong to one of the classes of the argument `nbs_of`
                         min.border = 0.2)
```

Once _'flat cells'_ have been identified, we will assume that raster cells surrounded by _'island shelf cells'_ are also _'island shelf cells'_. We define a cell as surrounded if 60% of its neighbors belong to an 'island shelf' class (_'hole cell'_, [Figure 2](#figure2)). 
```{r ISU_hole, message=FALSE, warning=FALSE, collapse = TRUE}
# ISU SHELF CELLS (FILL CLASSIFICATION HOLES)
holeCELLS <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                         
                         # `flatCELLS` class vector
                         classVector = flatCELLS, 
                         
                         # hole cell class
                         class = 3,    
                         
                         # evaluate cells adjacent to anchor cells (class=1), flat cells (class=2) or hole cells
                         nbs_of = c(1, 2, 3),
                         
                         # conditions are always true
                         conditions = "TRUE",
                         
                         # a cell is classified if at least 60% of its neighboring cells belong to one of the classes of the argument `nbs_of`
                         min.border = 0.6)    
```

Class vectors are updated each time they are passed to a classification function. Cells that have not been classified and that meet the conditions get a classification number. The class vector `holeCELLS` was the latest to be computed and resulted from the updates of `anchorCELL` and `flatCELLS`. Therefore, it includes all island shelf cells ([Figure 2](#figure2)). 

```{r classVect_exm, message=FALSE, warning=FALSE, collapse = TRUE}
# ISLAND SHELF CELLS

unique(holeCELLS)

# holeCELLS == 1,  ISU anchor cells
# holeCELLS == 2,  ISU flat cells
# holeCELLS == 3,  ISU hole cells
# holeCELLS == NA, Other cells
```


<a id="figure2"></a>
```{r ISU_shelf_map, message=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
rSC1 <- rstack[[1]]; rSC1[] <- NA; rSC1[ atbl$Cell[ holeCELLS == 2 ] ] <- 1
rSC2 <- rstack[[1]]; rSC2[] <- NA; rSC2[ atbl$Cell[ holeCELLS == 3 ] ] <- 1

rSC1 <- rasterToPolygons(rSC1, dissolve = TRUE)
rSC2 <- rasterToPolygons(rSC2, dissolve = TRUE)

rSC1$dummy <- 1
rSC2$dummy <- 1

m <-
  mapview(rAC, alpha.regions = 0.8, 
          col.regions = "orange", layer.name = "Anchor cell", popup = NULL, label = "ISU shelf cell (anchor cell)") + 
  mapview(rSC1, alpha.regions = 0.8, 
          col.regions = "#FFD700", layer.name = "Flat cell", popup = NULL, label = "ISU shelf cell (flat cell)") + 
  mapview(rSC2, alpha.regions = 0.8, 
          col.regions = "#A0522D", layer.name = "Hole cell", popup = NULL, label = "ISU shelf cell (hole cell)") + 
  mapview(rstack[[6]], layer.name = "SLOPE (deg)", col.regions = palYGB)

m@map %>% 
  hideGroup(c("SLOPE (deg)")) %>% 
  setView(lng = -28.40, lat = 38.55, zoom = 9) %>%
  addLayersControl(overlayGroups = c("Anchor cell", "Flat cell", "Hole cell", "SLOPE (deg)"),
                   position = "topleft",
                   options = layersControlOptions(collapsed = FALSE))
```
<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 2 -** **Anchor cell:** raster cells adjacent to a 'land cell'. **Flat cell:** raster cells with slopes < 5º respecting class contiguity and continuity with island shelf cells. **Hole cell:** raster cell whose 60% of neighboruring cells are classified as island shelf cells. **Slope:** slope values. Because of reprojection (resampling) displayed and original values might be slightly different.</span></div>

## 2.4 ISU - Slope cells
We can identify _'slope cells'_ using the function `cond.4.nofn()` to evaluate three sets of conditions. All sets of conditions will take into account class contiguity and continuity. 

___Slope1 cell.___ In the first set of conditions we consider that in regions adjacent to island shelves, _'slope cells'_ tend to have positive BPI values (`regional_bpi > 100`) (_'Slope1 cell'_, [Figure 3](#figure3)). 
```{r Slope1, message=FALSE, message=FALSE, warning=FALSE}
slope1 <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                      
                      # `holeCELLS` class vector
                      classVector = holeCELLS,
                      
                      # slope1 cell class
                      class = 4,
                      
                      # evaluate cells adjacent to ISU cells
                      nbs_of = c(1,2,3,4), 
                      
                      # condition string (regional_bpi refers to the column `regional_bpi` of `atbl`)
                      conditions = "regional_bpi > 100",
                      
                      # a cell is classified if conditions are true AND if at least 20% of its neighboring cells belongs to one of the classes of the argument `nbs_of`
                      min.border = 0.2)
```

___Slope2 cell.___ In the second set of conditions we consider that small ridges connected to the ISU are also part of the ISU. Small ridges tend to have high local BPI values (`local_bpi{} > 100`). Note that we use the tag `{}` after the variable `local_bpi` and the argument `fn_perc = 0.4`. The tag `{}` flags _absolute focal neighborhood conditions_, and `fn_perc = 0.4` states that the focal cell is classified only if conditions are true for at least 40% of the cells included in the focal neighborhood (_'Slope2 cells'_, [Figure 3](#figure3)).
```{r Slope2, message=FALSE, message=FALSE, warning=FALSE}
slope2 <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                      
                      # `slope1` class vector
                      classVector = slope1, 
                      
                      # slope2 cell class
                      class = 5,
                      
                      # evaluate cells adjacent to ISU cells
                      nbs_of = c(1,2,3,4,5), 
                      
                      # condition string (local_bpi refers to the column `local_bpi` of `atbl`, `{}` flags an absolute focal neighborhood condition)
                      conditions = "local_bpi{} > 100", 
                      
                      # a cell is classified if conditions are true for at least 40% of the cells in the focal cell neighborhood
                      fn_perc = 0.4,
                      
                      # a cell is classified if conditions are true AND if at least 20% of its neighboring cells belong to one of the classes of the argument `nbs_of`
                      min.border = 0.2)
```

___Slope3 cell.___ In the third set of conditions we consider that even cells having negative BPI values can be part of _'ISU slopes'_. We can assume that as long as there is an high bathymetric variation around a raster cell connected to a slope the seafloor has not been reached. We will set this condition using again the `{}` tag (`sd_bat{} > 150`), but we will change `fn_perc = 1` (_'Slope3 cell'_, [Figure 4](#figure4)).
```{r Slope3, message=FALSE, message=FALSE, warning=FALSE}
slope3 <- cond.4.nofn(atbl, nbs, nbsIndex = T,
                      
                      # `slope2` class vector
                      classVector = slope2, 
                      
                      # slope3 cell class
                      class = 6,
                      
                      # evaluate cells adjacent to ISU cells
                      nbs_of = c(1,2,3,4,5,6), 
                      
                      # condition string (sd_bat refers to the column `sd_bat` of `atbl`, `{}` flags an absolute focal neighborhood condition)
                      conditions = "sd_bat{} > 150", 
                      
                      # a cell is classified if conditions are true for 100% of the cells in the focal cell neighborhood
                      fn_perc = 1,
                      
                      # a cell is classified if conditions are true AND if at least 20% of its neighboring cells belong to one of the classes of the argument `nbs_of`
                      min.border = 0.2)
```

<a id="figure3"></a>
We can plot the result of the _'ISU slope'_ classification:
```{r ISU_slope_map, message=FALSE, warning=FALSE, echo=FALSE}
rSL1 <- rstack[[1]]; rSL1[] <- NA; rSL1[ atbl$Cell[ slope3 == 4 ] ] <- 1
rSL2 <- rstack[[1]]; rSL2[] <- NA; rSL2[ atbl$Cell[ slope3 == 5 ] ] <- 1
rSL3 <- rstack[[1]]; rSL3[] <- NA; rSL3[ atbl$Cell[ slope3 == 6 ] ] <- 1

rSL1 <- rasterToPolygons(rSL1, dissolve = TRUE)
rSL2 <- rasterToPolygons(rSL2, dissolve = TRUE)
rSL3 <- rasterToPolygons(rSL3, dissolve = TRUE)

rSL1$dummy <- 1
rSL2$dummy <- 1
rSL3$dummy <- 1

mapviewOptions(basemaps = c("Esri.OceanBasemap", "OpenStreetMap"))
m <-
  mapview(hs, col.regions = c("gray0", "gray50", "grey100"), alpha.regions=1, legend = FALSE, label = FALSE) + 
  
  mapview(rstack[["bathymetry_exm"]], layer.name = "bathymetry", col.regions = palRYB, legend = FALSE, alpha.regions = 0.5) +
  
  mapview(rSL1, alpha.regions = 0.8, col.regions = "#BFB5AF", layer.name = "Slope1 cell", popup = NULL, 
        label = "(regional_bpi > 100 & bathymetry{} > bathymetry) | regional_bpi > 300") +
  
  mapview(rSL2, alpha.regions = 0.8, layer.name = "Slope2 cell", col.regions = "#582C4D", popup = NULL, 
          label = "local_bpi{} > 100") +
  
  mapview(rSL3, alpha.regions = 0.8, layer.name = "Slope3 cell", col.regions = "black", popup = NULL, 
          label = "local_bpi{} > 100") +
  
  mapview(rAC, alpha.regions = 0.8, 
          col.regions = "orange", layer.name = "Anchor cell", popup = NULL, label = "ISU shelf cell (anchor cell)") + 
  
  mapview(rSC1, alpha.regions = 0.8, 
          col.regions = "#FFD700", layer.name = "Flat cell", popup = NULL, label = "ISU shelf cell (flat cell)") + 
  
  mapview(rSC2, alpha.regions = 0.8, 
          col.regions = "#A0522D", layer.name = "Hole cell", popup = NULL, label = "ISU shelf cell (hole cell)") + 
  
  mapview(rstack[["regional_bpi_exm"]], layer.name = "Regional_BPI", col.regions = palBYR, legend = FALSE, alpha.regions = 0.0) + 
  
  mapview(rstack[["local_bpi_exm"]], layer.name = "Local_BPI", col.regions = palBYR, legend = FALSE, alpha.regions = 0.0) + 
 
  mapview(rstack[["sd_bat_exm"]], layer.name = "SD_bathymetry", col.regions = palYGB, legend = FALSE, alpha.regions = 0.0)

m@map %>% 
  hideGroup(c("Anchor cell", "Flat cell", "Hole cell")) %>% 
  setView(lng = -28.43, lat = 38.45, zoom = 9) %>%
  addLayersControl(overlayGroups = c("Slope1 cell", "Slope2 cell", "Slope3 cell",
                                     "Anchor cell", "Flat cell", "Hole cell"),
                   position = "topleft",
                   options = layersControlOptions(collapsed = FALSE))
```
<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 3 -** Island shelf units (ISUs) identified by slope and island shelf cells. In background are provided BPI and SD bathymetry values; because of reprojection displayed and original values are slightly different.</span></div>

## 2.5 ISU - Class vector

The class vector `slope3` includes all ISU-cells ([Figure 3](#figure3)). It can be saved as an `*.RDS` file and used in the following classification steps.

```{r classVect_ISU, message=FALSE, warning=FALSE, collapse = TRUE}
# ISU CELLS
unique(slope3)

# slope3 == 1,  ISU anchor cells
# slope3 == 2,  ISU flat cells
# slope3 == 3,  ISU hole cells

# slope3 == 4,  ISU slope1 cells
# slope3 == 5,  ISU slope2 cells
# slope3 == 6,  ISU slope3 cells

# slope3 == NA, Non-ISU cells

# SAVE `slope3`
# saveRDS(slope3, "ISU_Cells.RDS")
```
