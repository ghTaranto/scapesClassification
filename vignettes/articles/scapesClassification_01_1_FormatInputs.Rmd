---
title: "Format inputs"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Format inputs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width = "100%", echo = TRUE, out.width="600px", fig.align='center', message=FALSE, warning=FALSE)
```


## Rasters 
[Raster*](https://rspatial.org/raster/spatial/4-rasterdata.html) objects are central to `(scapes)Classifications`. They define the area over which classifications are performed and provide the spatial data users deem important to build their classification rules. In addition, rasters provide information about where individual cells are located and how they relate with each other. As we will see in the next sections, raster cells are the basic unit of `(scapes)Classifications`. 

## Format inputs
Raster cells are numbered from the upper left cell to the upper right cell and then continuing on the left side of the next row, and so on until the last cell at the lower-right side of the raster ([RSpatial](https://rspatial.org/raster/pkg/8-cell_level_functions.html?highlight=cell%20number)). This numbering is used by the functions `attTbl()` and `ngbList()` to compute the attribute table and the neighborhood list.

### Attribute table
Making use of cell numbers, the function `attTbl()` converts a `Raster*` object into an attribute table (`data.frame`). Attribute tables come with a column named `Cell`. This column stores raster cell numbers and associates each row of the attribute table to a cell of the raster object. The remaining columns of the attribute table store the data contained in the layers of the `Raster*` object. 

> _Note that only raster cells having no missing values in no layer (i.e., complete cases) are included in the attribute table._

As an example we can consider a 3X3 raster and some dummy data ([Figure 1](#figure1)). 
```{r exm_rast}
# 3X3 RASTER
library(raster)
r <- raster(matrix(c(NA,100,100,NA,100,100,0,0,0),nrow = 3,ncol = 3,byrow = TRUE))
```

<a id="figure1"></a>
```{r exm_rast_plot, echo=FALSE}
# LOAD LIBRARIES
library(ggplot2)
library(reshape2)
library(ggpubr)

# CREATE A DUMMY RASTER
r <- raster(
  
  matrix(c(NA,100,100,NA,100,100,0,0,0),
         nrow = 3,
         ncol = 3,
         byrow = TRUE) )

# VISUALIZE RASTER CELL NUMBERS
m <- matrix(1:9, nrow=3, ncol=3, byrow = TRUE)

m <- t(m)[,nrow(m):1]
m <- melt(m, value.name = "cell")

p1 <- ggplot(m, aes(x=Var1, y=Var2)) +
  geom_tile(colour="gray90", lwd=1.5, show.legend = FALSE) +
  coord_fixed(ratio=1) + 
  geom_text(aes(label=cell), color = "white", family=c("serif"), size=8) + 
  theme_void()

# VISUALIZE RASTER DUMMY LAYER
r_plot <- as.matrix(r)
r_plot <- t(r_plot)[,nrow(r_plot):1]
r_plot <- melt(r_plot, value.name = "dummy")

r_plot$nas <- NA
r_plot$nas[which(is.na(r_plot$dummy))] <- 'NA'


p2 <- ggplot(r_plot, aes(x=Var1, y=Var2)) +
  geom_tile(colour="gray90", lwd=1.5, show.legend = FALSE) +
  coord_fixed(ratio=1) + 
  geom_text(aes(label=dummy), color = "white", family=c("serif"), size=8, na.rm=TRUE) + 
  geom_text(aes(label=nas), color = "red", family=c("serif"), size=8, fontface='bold', na.rm=TRUE) +
  theme_void()

ggarrange(p1, p2, labels = c("Cell numbers", "Dummy data"), label.y=0.96, label.x=-0.19, 
          font.label = list(size = 20, color = "black", face = "bold", family = "serif"))
```
<div style="line-height: 0.8em; margin-bottom: 1.5em; text-align: center;"><span class="legend">**Figure 1 -** Example of a raster object. On the left, raster cell numbers; on the right raster data.</span></div>

We can compute the attribute table with the following code chunk. Note that raster cells 1 and 4 have missing values, therefore, they are not included in the attribute table.
```{r atbl, collapse=TRUE}
# ATTRIBUTE TABLE
library(scapesClassification)

attTbl(r, var_names = c("dummy_var"))
```


### List of neighborhoods 
The values and classes existing in the neighborhood of a raster cell can be used to define classification rules. The function `ngbList()` speeds up the evaluation of classification rules by computing and storing in memory as a `list` raster cells' neighborhoods.  

The function `ngbList()` is coded based on the following points:

> * The neighborhood of a raster cell with coordinates `(x, y)` counts 8 neighbors with coordinates `(x±1, y)`,  `(x, y±1)` and `(x±1, y±1)`. Note that edge cells have less than 8 neighbors; 


> * Neighborhoods of cells presenting one or more missing values are not computed (_e.g., cells 1 and 4 of [Figure 1](#figure1)_); 

 
> * With the argument `rNumb = FALSE`,  the neighbors are identified by cell numbers (_e.g., neighbors of cell 2 of [Figure 1](#figure1) are cells `1, 3, 4, 5, 6`_);

 
> * With the argument `rNumb = TRUE`,  the neighbors are identified by row numbers and neighbors with missing values are omitted (_e.g., neighbors of cell 2 of [Figure 1](#figure1) are in the rows of the attribute table `2, 3, 4` which correspond to cells  `3, 5, 6`_);


As an example let's consider the raster `r` plotted in [Figure 1](#figure1). 
```{r nbsList}
# ATTRIBUTE TABLE
at <- attTbl(r, var_names = c("dummy_var"))

# NEIGHBORHOODS - CELL NUMBERS
nbs_CELL <- ngbList(r, rNumb = FALSE)

# NEIGHBORHOODS - ROW NUMBERS
nbs_ROW <- ngbList(r, rNumb = TRUE, attTbl = at)
```

```{r nbsList_cn, collapse=TRUE}
#NEIGHBORHOODS - CELL NUMBER

# Cells 1 and 4 are omitted because they are NAs -> 
# The top three elements of the list are cells 2, 3 and 5
head(nbs_CELL, 3)
```

```{r nbsList_rn, collapse=TRUE}
#NEIGHBORHOODS - ROW NUMBER

# Cells 1 and 4 are omitted because they are NAs -> 
# The top three elements of the list are in rows 1, 2 and 3
head(nbs_ROW, 3)

# Rows 1, 2 and 3 correspond to cells 2, 3 and 5
at$Cell[1:3]
```

```{r nbsList_rn_ex, collapse=TRUE}
# LET'S CONSIDER THE NEIGHBORHOOD OF CELL #2

# Cell #2 corresponds to the 1st element of both 'nbs_CELL' and 'nbs_ROW'

# These are cell numbers
nbs_CELL[1]

# These are row numbers
nbs_ROW[1]

# Row numbers can be converted into cell numbers
at$Cell[ nbs_ROW[[1]] ]

# Cells 1 and 4 are omitted from at$Cell[ nbs_ROW[[1]] ] 
# because they have missing values
r[c(1,4)]
```

<br />

> The list of neighborhoods is computed ans stored in memory to improve the performance of the classification algorithms. The performance increase is greater when neighbors are identified by row numbers rather than by cell numbers.

## Classification rules evaluation 
Classification rules can be evaluated for all raster cells simultaneously. For instance, when we set one or more threshold values (e.g. `cell value > threshold`) or when we evaluate at what locations a shapefile overlap our raster. 

In other cases it can be more fruitful to perform targeted evaluations. For instance, we might want to evaluate classification rules only for cells at specific positions on the raster surface. Imagine we have a raster cell that has already been classified and we want to evaluate if its neighboring cells belong to the same class based on some rule. 


let's consider that we have an island shapefile from which we can derive what raster cells represent land positions (see [working example](https://ghtaranto.github.io/scapesClassification/articles/scapesClassification_02_2_ISU.html)). 


```{r rast_matrix, message=FALSE, warning=FALSE, echo=FALSE, include=FALSE}
library(gifski)
library(ggplot2)
library(reshape2)

fc_tc <- function(FC){
  
  m  <- matrix(1:49,nrow = 7, ncol = 7, byrow = TRUE)
  # FC <- 25
  
  r   <- raster::raster(m)
  r[] <- NA
  
  FCN <- scapesClassification::nbg8(7,7)[[as.character(FC)]] 
  
  # ORDER PLOTS
  f <- "forestgreen"
  r <- "firebrick"
  
  ord <- c(5,8,7,6,4,1,2,3)
  cls <- c(f,f,f,r,r,r,r,r)
  FCN <- FCN[ord]
  
  for(i in 1:length(FCN)){
    
    r   <- raster::raster(m)
    r[] <- NA
    
    TC <- FCN[i]
    
    r[ FC ]  <- 0
    r[ TC ]  <- 1
    
    r_long <- melt(raster::as.matrix(r))
    
    r_long$label <- as.character(NA)
    r_long$label[which(r_long$value == 0)] <- "FC"
    r_long$label[which(r_long$value == 1)] <- "TC"
    r_long$value <- as.factor(r_long$value)
    
    tc_cord <- r_long[which(r_long$value == 1), c("Var1", "Var2")]
    
    x0 <- tc_cord$Var1 - 1.5
    x1 <- tc_cord$Var1 + 1.5
    y0 <- tc_cord$Var2 - 1.5
    y1 <- tc_cord$Var2 + 1.5
    
    if(i == 1){
      r_long$pts <- "transparent"
    } else {
      r_long$pts <- pts
    }
    
    p <- ggplot(r_long, aes(x=Var1, y=Var2)) +
      geom_tile(aes(fill=value), colour="gray90", lwd=1.5, show.legend = FALSE) +
      coord_fixed(ratio=1) + 
      geom_text(aes(label=label), color = "white", family=c("serif"), size=9) + 
      scale_fill_manual(values = c("#1088a0", "goldenrod3"), na.value = "black") + 
      geom_rect(aes(xmin = 2.5, xmax = 5.5, ymin = 2.5, ymax = 5.5), fill = "transparent", color="#1088a0", lwd = 1.5) + 
      geom_rect(aes(xmin = x0, xmax = x1, ymin = y0, ymax = y1), fill = "transparent", color="goldenrod3", lwd = 1.5) + 
      geom_point(aes(x=Var1, y=Var2, color= pts), size = 9) +  scale_colour_identity() +
      theme_void()
    
    print(p)
    
    pts <- r_long$pts
    pts[which(r_long$value==1)] <- cls[i]
  }
  
  r_long$value[which(r_long$value == 1)] <- NA
  r_long$value[which(r_long$pts == f | r_long$value == 0)] <- 1
  
  r_long$pts <- pts
  r_long$label[which(r_long$label == "TC")] <- NA
  
  p <- ggplot(r_long, aes(x=Var1, y=Var2)) +
    geom_tile(aes(fill=value), colour="gray90", lwd=1.5, show.legend = FALSE) +
    coord_fixed(ratio=1) + 
    geom_text(aes(label=label), color = "white", family=c("serif"), size=9) +
    scale_fill_manual(values = c("#1088a0", "goldenrod3"), na.value = "black") + 
    geom_rect(aes(xmin = 2.5, xmax = 5.5, ymin = 2.5, ymax = 5.5), fill = "transparent", color="#1088a0", lwd = 1.5) +
    # geom_rect(aes(xmin = x0, xmax = x1, ymin = y0, ymax = y1), fill = "transparent", color="goldenrod3", lwd = 1.5) + 
    geom_point(aes(x=Var1, y=Var2, color= pts), size = 9) +  scale_colour_identity() +
    theme_void()
  
  print(p)
  print(p)
  print(p)
  print(p)
  print(p)
}

gifski::save_gif(fc_tc(25), "fc_tc.gif", delay = 0.7, width = 800, 
         height = 800, progress = FALSE, loop = 5)
```

```{r gif, message=FALSE, warning=FALSE, echo=FALSE, out.width="600px", fig.align='center'}
knitr::include_graphics("fc_tc.gif")
```


The most basic information all rasters have is the position of each raster cell in space, and how individual cells spatially relate with each other. This information is of key importance 


`(scapes)Classifications` are performed on raster surfaces. Rasters are made up of a matrix of pixels (also called cells), each corresponding to a specific geographic location.

`(scapes)Classifications` proceed classifying raster cells based on sets of classification rules that evaluate to true or false.  These conditions can be :

* The value of the raster cell;

* Value comparisons among the cell being tested and its neighborhood;  

* Spatial relationships between classes. 
