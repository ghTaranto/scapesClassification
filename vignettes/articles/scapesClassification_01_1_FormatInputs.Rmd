---
title: "Format inputs"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Format inputs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width = "100%", echo = TRUE, out.width="600px", fig.align='center', message=FALSE, warning=FALSE)
```


## Rasters 
[`Raster*`](https://rspatial.org/raster/spatial/4-rasterdata.html) objects are central to `(scapes)Classifications`. They define the area over which classifications are performed and provide the spatial data users deem important to build their classification rules. In addition, all rasters provide information about where individual cells are located and how they relate with each other. As we will see in the next paragraphs, raster cells are the basic unit of `(scapes)Classifications`. 

## Format inputs
Raster cells are numbered from the upper left cell to the upper right cell and then continuing on the left side of the next row, and so on until the last cell at the lower-right side of the raster ([RSpatial](https://rspatial.org/raster/pkg/8-cell_level_functions.html?highlight=cell%20number)). This numbering is used by the functions `attTbl()` and `ngbList()` to compute the attribute table and the neighborhood list.

### Attribute table
Making use of cell numbers, the function `attTbl()` converts `Raster*` objects into an attribute table (`data.frame`). Attribute tables come with a column named `Cell` which stores raster cell numbers and associate each row of the attribute table with a cell of the raster object. Each of the remaining columns stores the values of a layer of the 
`Raster*` object. Note that only raster cells having no missing value in any layer (complete cases) are included in the attribute table.

As an example we can consider a 3X3 raster and some dummy data ([Figure 1](#figure1)). 
```{r exm_rast}
# 3X3 RASTER
library(raster)
r <- raster(matrix(c(NA,100,100,NA,100,100,0,0,0),nrow = 3,ncol = 3,byrow = TRUE))
```

<a id="figure1"></a>
```{r exm_rast_plot, echo=FALSE}
# LOAD LIBRARIES
library(ggplot2)
library(reshape2)
library(ggpubr)

# CREATE A DUMMY RASTER
r <- raster(
  
  matrix(c(NA,100,100,NA,100,100,0,0,0),
         nrow = 3,
         ncol = 3,
         byrow = TRUE) )

# VISUALIZE RASTER CELL NUMBERS
m <- matrix(1:9, nrow=3, ncol=3, byrow = TRUE)

m <- t(m)[,nrow(m):1]
m <- melt(m, value.name = "cell")

p1 <- ggplot(m, aes(x=Var1, y=Var2)) +
  geom_tile(colour="gray90", lwd=1.5, show.legend = FALSE) +
  coord_fixed(ratio=1) + 
  geom_text(aes(label=cell), color = "white", family=c("serif"), size=8) + 
  theme_void()

# VISUALIZE RASTER DUMMY LAYER
r_plot <- as.matrix(r)
r_plot <- t(r_plot)[,nrow(r_plot):1]
r_plot <- melt(r_plot, value.name = "dummy")

r_plot$nas <- NA
r_plot$nas[which(is.na(r_plot$dummy))] <- 'NA'


p2 <- ggplot(r_plot, aes(x=Var1, y=Var2)) +
  geom_tile(colour="gray90", lwd=1.5, show.legend = FALSE) +
  coord_fixed(ratio=1) + 
  geom_text(aes(label=dummy), color = "white", family=c("serif"), size=8, na.rm=TRUE) + 
  geom_text(aes(label=nas), color = "red", family=c("serif"), size=8, fontface='bold', na.rm=TRUE) +
  theme_void()

ggarrange(p1, p2, labels = c("Cell numbers", "Dummy data"), label.y=0.96, label.x=-0.19, 
          font.label = list(size = 20, color = "black", face = "bold", family = "serif"))
```
<div style="line-height: 0.8em; margin-bottom: 1.5em; text-align: center;"><span class="legend">**Figure 1 -** Example of a raster object. On the left, raster cell numbers; on the right raster data.</span></div>

We can compute the attribute table with the following code chunk. Note that raster cells 1 and 4 have missing values, therefore, they are not included in the attribute table.
```{r atbl}
# ATTRIBUTE TABLE
library(scapesClassification)

attTbl(r, var_names = c("dummy_var"))
```


### List of neighborhoods 
The evaluation of classification rules depends on what values and classes exist in the neighborhood of a raster cell. The neighborhood of each raster cell is computed and stored in a list by the function `ngbList()`:

* Excluding cells on the edge of a raster, a cell with coordinates `(x, y)` has 8 neighbors with coordinates: `(x±1, y)`,  `(x, y±1)` and `(x±1, y±1)`; 

* Neighborhoods of cells presenting one or more missing values are not computed (e.g., cells 1 and 4 in [figure 1](#figure1)); 

* With the argument `rNumb = FALSE`  the neighbors are identified by cell numbers (e.g., neighbors of cell 2 in [figure 1](#figure1) are cells `1, 3, 4, 5, 6`);

* With the argument `rNumb = TRUE`  the neighbors are identified by row numbers and neighbors with missing values are omitted (e.g., neighbors of cell 2 in [figure 1](#figure1) are in the rows of the attribute table `2, 3, 4` which correspond to cells  `3, 5, 6`);


As an example let's consider the raster `r` plotted [Figure 1](#figure1) and compute the list of neighborhoods. 

```{r nbsList}
# ATTRIBUTE TABLE
at <- attTbl(r, var_names = c("dummy_var"))

# NEIGHBORHOODS - CELL NUMBERS
nbs_CELL <- ngbList(r, rNumb = FALSE)

# NEIGHBORHOODS - ROW NUMBERS
nbs_ROW <- ngbList(r, rNumb = TRUE, attTbl = at)
```

```{r nbsList_cn, collapse=TRUE}
#NEIGHBORHOODS - CELL NUMBER

# Cells 1 and 4 are omitted because they are NAs -> 
# The top three elements of the list are cells 2, 3 and 5
head(nbs_CELL, 3)
```

```{r nbsList_rn, collapse=TRUE}
#NEIGHBORHOODS - ROW NUMBER

# Cells 1 and 4 are omitted because they are NAs -> 
# The top three elements of the list are in rows 1, 2 and 3
# which correspond to cells 2, 3 and 5
head(nbs_ROW, 3)

# Cells in the top three rows of the attribute table
at$Cell[1:3]
```

```{r nbsList_rn_ex, collapse=TRUE}
# LET'S CONSIDER THE NEIGHBORHOOD OF CELL #2

# These are cell numbers
nbs_CELL[1]

# These are not cell numbers...
nbs_ROW[1]

# But these are cell numbers
at$Cell[ nbs_ROW[[1]] ]

# Cells 1 and 4 are omitted from at$Cell[ nbs_ROW[[1]] ] 
# because they have missing values
r[c(1,4)]
```

<br />

> The list of neighborhoods is computed to improve the performance of the classification algorithms implemented in `(scapes)Classifications`. The performance increase is greater when neighbors are identified by row numbers. 


## Classification rules evaluation 
Classification rules can be evaluated for all raster cells simultaneously. For instance, when we set one or more threshold values (e.g. `cell value > threshold`) or when we evaluate at what locations a shapefile overlap our raster. 

In other cases it can be more fruitful to perform targeted evaluations. For instance, we might want to evaluate classification rules only for cells at specific positions on the raster surface. Imagine we have a raster cell that has already been classified and we want to evaluate if its neighboring cells belong to the same class based on some rule. 


let's consider that we have an island shapefile form which we can derive what raster cells represent land positions (see [working example](https://ghtaranto.github.io/scapesClassification/articles/scapesClassification_02_2_ISU.html)). 


```{r rast_matrix, message=FALSE, warning=FALSE, echo=FALSE, include=FALSE}
library(gifski)
library(ggplot2)
library(reshape2)

fc_tc <- function(FC){
  
  m  <- matrix(1:49,nrow = 7, ncol = 7, byrow = TRUE)
  # FC <- 25
  
  r   <- raster::raster(m)
  r[] <- NA
  
  FCN <- scapesClassification::nbg8(7,7)[[as.character(FC)]] 
  
  # ORDER PLOTS
  f <- "forestgreen"
  r <- "firebrick"
  
  ord <- c(5,8,7,6,4,1,2,3)
  cls <- c(f,f,f,r,r,r,r,r)
  FCN <- FCN[ord]
  
  for(i in 1:length(FCN)){
    
    r   <- raster::raster(m)
    r[] <- NA
    
    TC <- FCN[i]
    
    r[ FC ]  <- 0
    r[ TC ]  <- 1
    
    r_long <- melt(raster::as.matrix(r))
    
    r_long$label <- as.character(NA)
    r_long$label[which(r_long$value == 0)] <- "FC"
    r_long$label[which(r_long$value == 1)] <- "TC"
    r_long$value <- as.factor(r_long$value)
    
    tc_cord <- r_long[which(r_long$value == 1), c("Var1", "Var2")]
    
    x0 <- tc_cord$Var1 - 1.5
    x1 <- tc_cord$Var1 + 1.5
    y0 <- tc_cord$Var2 - 1.5
    y1 <- tc_cord$Var2 + 1.5
    
    if(i == 1){
      r_long$pts <- "transparent"
    } else {
      r_long$pts <- pts
    }
    
    p <- ggplot(r_long, aes(x=Var1, y=Var2)) +
      geom_tile(aes(fill=value), colour="gray90", lwd=1.5, show.legend = FALSE) +
      coord_fixed(ratio=1) + 
      geom_text(aes(label=label), color = "white", family=c("serif"), size=9) + 
      scale_fill_manual(values = c("#1088a0", "goldenrod3"), na.value = "black") + 
      geom_rect(aes(xmin = 2.5, xmax = 5.5, ymin = 2.5, ymax = 5.5), fill = "transparent", color="#1088a0", lwd = 1.5) + 
      geom_rect(aes(xmin = x0, xmax = x1, ymin = y0, ymax = y1), fill = "transparent", color="goldenrod3", lwd = 1.5) + 
      geom_point(aes(x=Var1, y=Var2, color= pts), size = 9) +  scale_colour_identity() +
      theme_void()
    
    print(p)
    
    pts <- r_long$pts
    pts[which(r_long$value==1)] <- cls[i]
  }
  
  r_long$value[which(r_long$value == 1)] <- NA
  r_long$value[which(r_long$pts == f | r_long$value == 0)] <- 1
  
  r_long$pts <- pts
  r_long$label[which(r_long$label == "TC")] <- NA
  
  p <- ggplot(r_long, aes(x=Var1, y=Var2)) +
    geom_tile(aes(fill=value), colour="gray90", lwd=1.5, show.legend = FALSE) +
    coord_fixed(ratio=1) + 
    geom_text(aes(label=label), color = "white", family=c("serif"), size=9) +
    scale_fill_manual(values = c("#1088a0", "goldenrod3"), na.value = "black") + 
    geom_rect(aes(xmin = 2.5, xmax = 5.5, ymin = 2.5, ymax = 5.5), fill = "transparent", color="#1088a0", lwd = 1.5) +
    # geom_rect(aes(xmin = x0, xmax = x1, ymin = y0, ymax = y1), fill = "transparent", color="goldenrod3", lwd = 1.5) + 
    geom_point(aes(x=Var1, y=Var2, color= pts), size = 9) +  scale_colour_identity() +
    theme_void()
  
  print(p)
  print(p)
  print(p)
  print(p)
  print(p)
}

gifski::save_gif(fc_tc(25), "fc_tc.gif", delay = 0.7, width = 800, 
         height = 800, progress = FALSE, loop = 5)
```

```{r gif, message=FALSE, warning=FALSE, echo=FALSE, out.width="600px", fig.align='center'}
knitr::include_graphics("fc_tc.gif")
```


The most basic information all rasters have is the position of each raster cell in space, and how individual cells spatially relate with each other. This information is of key importance 


`(scapes)Classifications` are performed on raster surfaces. Rasters are made up of a matrix of pixels (also called cells), each corresponding to a specific geographic location.

`(scapes)Classifications` proceed classifying raster cells based on sets of classification rules that evaluate to true or false.  These conditions can be :

* The value of the raster cell;

* Value comparisons among the cell being tested and its neighborhood;  

* Spatial relationships between classes. 
