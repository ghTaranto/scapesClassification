---
title: "Classification functions"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Classification functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align='center', message=FALSE, warning=FALSE, out.width = "100%")
```

## Class vectors

Class vectors map raster cells to numeric classes (or to NA-values if no class is attributed). The n^th^ element of a class vector corresponds to the raster cell stored in the n^th^ row of an [attribute table](scapesClassification_01_1_FormatInputs.html#attribute-table). Class vectors are used by classification functions to store the results of their classifications. 

Class vectors can also be used as function inputs. As inputs, they provide information about what cells have been classified and allow to consider class contiguity and class continuity in rule evaluation (see the article ["rule evaluation"](scapesClassification_01_2_RuleEvaluation.html)). 

When a class vector is provided as an input, classification functions assign a class only to unclassified cells (i.e. cells corresponding to NA values in the class vector). In this way class vectors are updated (and not overwritten) every time the are provided as a function input. The function `anchor.seed()` is the only exception. 

## Anchor cell functions

**Functions:** `anchor.svo()`, `anchor.cell()` and `cond.4.all()`.

Anchor cells can be thought of as raster cells having particular characteristics from where the classification process can start. Anchor cells can be derived by: previous classifications, areas of constant environmental or geographic characteristics (e.g., flat areas), local maxima or minima (e.g., local peaks on a mountain ridge) or spatial objects (e.g., shapefiles).  

Anchor cell functions can be easily identified because they do not necessarily require a class vector as an input. 

### anchor.svo and anchor.cell

To illustrate the functions `anchor.svo()` and `anchor.cell()` we will use the data stored within the package. These data include several raster layers around the central group of the Azores Islands and the shapefile of the islands (see the article ["island shelf unit"](scapesClassification_02_2_ISU.html) for additional details).  

We will start by loading the data and the libraries and by computing the attribute table and the list of neighborhoods. 

```{r loadLD, message=FALSE, warning=FALSE, collapse = TRUE, class.source = 'fold-hide'}
# LOAD LIBRARIES
library(raster)
library(scapesClassification)

# LOAD DATA
grd <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T)
grd <- grd[grepl("\\.grd", grd)]
grd <- grd[!grepl("hillshade", grd)]
rstack <- stack(grd)

# COMPUTE ATTRIBUTE TABLE
atbl <- attTbl(rstack, var_names = c("bathymetry", "gmorph", "local_bpi", "regional_bpi", "sd_bat", "slope"))

# COMPUTE NEIGHBORHOOD LIST
nbs <- ngbList(rstack, rNumb = TRUE, attTbl = atbl) # neighbors are identified by their row number in the attribute table

# ISLAND SHAPEFILE PATH
shp <- system.file("extdata", "Azores.shp", package = "scapesClassification")
```

The function `anchor.svo()` returns a vector of cell numbers extracted at the locations of a spatial vector object. In this case it will extract "land cells" at the locations of the island shapefile. 

Function arguments:

* `only_NAs = TRUE`, cell numbers extracted only at the locations of a spatial vector object that are not complete cases (i.e. have some missing values in some of the layers of the `Raster*` object).

* `fill_NAs = TRUE`, cell numbers extracted also at locations contiguous to those of the spatial vector object that are not complete cases (i.e. have some missing values in some of the layers of the `Raster*` object). 

```{r ISU_land, message=FALSE, warning=FALSE, collapse = TRUE}
# EXTRACT LAND POSITIONS
anchorLAND <- anchor.svo(rstack              = rstack, 
                         spatial_vector_name = shp, 
                         only_NAs            = TRUE, 
                         fill_NAs            = TRUE, 
                         plot                = FALSE)

# CELL NUMBERS AT THE LOCATION OF `shp`
head(anchorLAND)
```

The function `anchor.cell()` converts a vector of cell numbers into a class vector. In this case we want to attribute a classification number (argument `class = 1`) to cells adjacent to land cells.

Function arguments:

* `class2cell = FALSE`, the classification number is not attributed to cells included in the vector `anchorLAND`. 

* `class2nbs = TRUE`, the classification number is attributed to cells adjacent to those included in the vector `anchorLAND`. 

```{r ISU_anchor, message=FALSE, warning=FALSE, collapse = TRUE}
# COMPUTE ANCHOR CELLS
anchorCELL <- anchor.cell(attTbl     = atbl, 
                          rstack     = rstack, 
                          anchor     = anchorLAND, 
                          class      = 1,
                          class2cell = FALSE,
                          class2nbs  = TRUE,
                          plot       = FALSE) 

# EXTRACT anchorCELL FROM THE ATTRIBUTE TABLE
head( atbl$Cell[which(anchorCELL == 1)] )
```

Finally we can visualize our results using the packages `mapview` and `leaflet` ([Figure 1](#figure1)).

<a id="figure1"></a>
```{r leaflet, message=FALSE, message=FALSE, warning=FALSE, echo=FALSE}
library(mapview)
library(leaflet)

# set gerenal options 
mapviewOptions(basemaps = c("OpenStreetMap"), na.color = "grey88", homebutton = FALSE, 
               query.position = "bottomright", legend.opacity = 0.9)

# ISU_anchor
island <- rgdal::readOGR(dsn = shp, verbose = F)
island <- sp::spTransform(island, raster::crs(rstack))
island$BASE[c(5,4,49)] <- c("Pico", "Faial", "Sao Jorge") # mouseover labels

rL  <- rstack[[1]]; rL[]  <- NA; rL[anchorLAND] <- 1
rAC <- rstack[[1]]; rAC[] <- NA; rAC[atbl$Cell] <- anchorCELL

# convert to polygon so that mapview projection does not affect visualization
rL  <- rasterToPolygons(rL, dissolve = TRUE)
rAC <- rasterToPolygons(rAC, dissolve = TRUE)

# add a column so that mapview legend reads layer.name and not values
rL$dummy  <- 1
rAC$dummy <- 1

mv <- 
  mapview(rAC, alpha.regions = 1, 
             col.regions = "orange", layer.name = "Anchor cell", popup = NULL, label = "Anchor Cell") + 
  mapview(rL, alpha.regions = 1, 
          col.regions = "black", layer.name = "Land cell", popup = NULL, label = "Land cell") + 
  mapview(island, alpha.region = 0, col.regions = "cyan", color = "cyan", lwd = 2, label = "BASE", 
          layer.name = "Island shapefile", popup = NULL)

mv@map %>% 
  setView(lng = -28.35, lat = 38.59, zoom = 10) %>%
  addLayersControl(baseGroups = c("OpenStreetMap", "Esri.OceanBasemap"),
                   overlayGroups = c("Anchor cell", "Land cell", "Island shapefile"),
                   position = "topleft",
                   options = layersControlOptions(collapsed = TRUE))
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 1 -** **Anchor cell:** raster cells adjacent to a 'land cell'. **Land cell**: raster cells extracted at the locations of the 'island shapefile' that are not complete cases and all adjacent cells that are not complete cases either. **Island shapefile**: the shapefile of Faial, Pico and SÃ£o Jorge Islands.</span></div>


### cond.4.all()

To illustrate the function `cond.4.all()` and the other `scapesClassification` functions we will use a dummy raster ([Figure 2](#figure2)), compute its [attribute table](scapesClassification_01_1_FormatInputs.html#attribute-table), in which it is named `"dummy_var"` and compute its [list of neighborhoods](scapesClassification_01_1_FormatInputs.html#list-of-neighborhoods).

```{r def, message=FALSE, warning=FALSE, echo=TRUE}
# LOAD THE DUMMY RASTER
r <- list.files(system.file("extdata", package = "scapesClassification"), 
                 pattern = "dummy_raster\\.tif", full.names = T)
r <- raster(r)
```

```{r def_at, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# COMPUTE THE ATTRIBUTE TABLE
at <- attTbl(r, "dummy_var")

head(at)

# COMPUTE THE LIST OF NEIGBORHOODS
nbs <- ngbList(r)

head(nbs)
```

<a id="figure2"></a>

```{r dummy_rast_plot, message=FALSE, warning=FALSE, echo=TRUE}
# PLOT RASTER
par(mar = c(0.1, 5, 0.5, 0.1))
plot(r, axes=FALSE, box=FALSE, legend = FALSE)
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 2 -** Dummy raster used to illustrate `scapesClassification` functions.</span></div>

---

The function `cond.4.all()` can be used to evaluate absolute test cell conditions (see `?conditions` and the article ["classificaton rules"](scapesClassification_01_3_ClassRules.html)) performing global evaluations (see the article ["rule evaluation"](scapesClassification_01_2_RuleEvaluation.html)). 

Using the dummy raster as an example, we can identify all cells having a value of 1. Classification rules are built accessing by name the variables stored in the attribute table (classification rule: `"dummy_var == 1"`). 

```{r cond_4_all1, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# ATTRIBUTE TABLE VARIABLES
names(at)

# COMPUTE THE CLASS VECTOR
cv   <- cond.4.all(attTbl = at, conditions = "dummy_var == 1", class = 10)

# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv <- cv.2.rast(r, at$Cell, classVector = cv)
```

The element `cv` is a class vector. The classification number `10` (argument `class = 10`) was assigned to all cells having a value equal to 1 (argument `conditions = "dummy_var == 1"`). 

The element `r_cv` is the class vector `cv` converted into a raster by the function `cv.2.rast()`. It can be plotted and manipulated as a normal raster object ([Figure 3](#figure3)).

<a id="figure3"></a>
```{r cond_4_all1_plot, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# CLASS VECTOR LEVELS
unique(cv)

# class = 10, cell with values 'dummy_var == 1'
# class = NA, unclassified cells

# PLOT THE CLASS VECTOR
par(mar = c(0.1, 5, 0.5, 0.1))
plot(r_cv, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", col="#78b2c4")
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 3 -** Raster cell classification using the function **cond.4.all** and the rule `conditions = "dummy_var == 1"`. In **blue**, classified cells (corresponding to the positions `cv == 10`). In **grey**, unclassified cells.</span></div>

---

When no class vector is available, the function `cond.4.all()` can be used to begin a classification process, but it can also be used at other stages of a classification process. For instance, consider the rule `"dummy_var <= 3"`. This rule applied on our dummy raster would classify raster cells having values of 1, 2 and 3. However, providing the class vector `cv` as a function input, the function would update the class vector ignoring classified cells (non-NA cells in the class vector) ([Figure 4](#figure4)).

```{r cond_4_all2, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# UPDATE THE CLASS VECTOR

# UPDATED CLASS VECTOR
cv   <- cond.4.all(attTbl = at, conditions = "dummy_var <= 3", class = 1,
                   
                   # INITIAL CLASS VECTOR
                   classVector = cv) 

# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv <- cv.2.rast(r, at$Cell, classVector = cv)
```

The class vector `cv` presents now two classification numbers, number `10` assigned in the previous evaluation and number `1` assigned in the last evaluation. 

<a id="figure4"></a>
```{r cond_4_all2_plot, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# CLASS VECTOR LEVELS
unique(cv)

# class = 10, cell with values 'dummy_var == 1'
# class = 1,  cell with values 'dummy_var =< 3'
# class = NA, unclassified cells

# PLOT THE CLASS VECTOR
par(mar = c(0.1, 2, 0.5, 0.1))
plot(r_cv, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", col=c("#cfad89", "#78b2c4"))
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 4 -** Two-step classification using the function **cond.4.all**. Step one (**light blue**), cells classified using the rule `conditions = "dummy_var == 1"`. Step two (**brown**), cells classified using the rule `conditions = "dummy_var <= 3"`. In **grey**, unclassified cells. Note that the rule of step two do not overwrite the classification of step one.</span></div>

## User condition functions

**Functions:** `cond.4.nofn()`, `cond.reclass()` and `cond.4.all()`.

User condition functions present the `conditions` argument and generally require a class vector as input. Excluding the function `cond.4.all()` (that can be considered both an anchor cell and a user condition function), user condition functions always perform [focal evaluations](scapesClassification_01_2_RuleEvaluation.html#focal-evaluation). Focal evaluations only test classification rules at positions adjacent to particular raster cells, anchor and focal cells. Anchor and focal cells are identified by the function argument `nofn`. 

A particular case of focal evaluation, is [class continuity](scapesClassification_01_2_RuleEvaluation.html#class-continuity). Class continuity join into the same class cells that share the same property(ies) and that are connected to the same anchor cell(s). User condition functions take into account class continuity when the classification number assigned with the argument `class` is also included in the argument `nofn`. 

### cond.4.nofn

The function `cond.4.nofn()` can be used to evaluate both relative and absolute conditions (see `?conditions` and ["classificaton rules"](scapesClassification_01_3_ClassRules.html)). We will start by presenting some absolute conditions. 

As all other user condition functions, `cond.4.nofn()` requires some focal cell class to be specified by the argument `nofn`. We can create an empty class vector and assume that `cell 25` is our initial focal cell. The focal cell will be identified by the numeric class `0` - but we could use any other number.

```{r cond_4_nofn0, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# SET CELL 32 AS A FOCAL CELL
at$cv[at$Cell == 25] <- 0
```

We can now use the function `cond.4.nofn()` to find cells with `"dummy_var >= 3"` at locations adjacent to the focal cell ([Figure 5](#figure5)).

```{r cond_4_nofn1, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# COMPUTE THE CLASS VECTOR (do not consider class continuity)
cv1 <- cond.4.nofn(attTbl = at, 
                   ngbList = nbs, 
                   
                   # CLASS VECTOR - INPUT
                   classVector = at$cv, 
                   
                   # FOCAL CELL CLASS
                   nbs_of = 0, 
                   
                   # CLASSIFICATION NUMBER
                   class = 1,  
                   
                   # ABSOLUTE CONDITION
                   conditions = "dummy_var >= 3")


# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv1 <- cv.2.rast(r, at$Cell,classVector = cv1, plot = FALSE)
```

<a id="figure5"></a>
 
```{r cond_4_nofn1_plot, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# CLASS VECTOR LEVELS
unique(cv1)

# class = 0,  focal cell
# class = 1,  cell with values 'dummy_var >= 3'
# class = NA, unclassified cells

# PLOT THE CLASS VECTOR
par(mar = c(0.1, 2, 0.5, 0.1))
plot(r_cv1, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 5 -** Classification using the function **cond.4.nofn** and the rule `conditions = "dummy_var >= 3"`. In **light blue**, the initial focal cell; in **brown** cell meeting function conditions; in **grey**, unclassified cells. Only **cells contiguous** to the focal cell with values `>=3` are identified by the function.</span></div>

---

When the classification number associated with the argument `class` is also included in the argument `nofn`, classifications take into account [class continuity](scapesClassification_01_2_RuleEvaluation.html#class-continuity) ([Figure 6](#figure6)). 

```{r cond_4_nofn2, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# COMPUTE THE CLASS VECTOR (consider class continuity)
cv2 <- cond.4.nofn(attTbl = at, 
                   ngbList = nbs, 
                   
                   # CLASS VECTOR - INPUT
                   classVector = at$cv, 
                   
                   nbs_of = c(0,  # FOCAL CELL CLASS
                              1), # CLASSIFICATION NUMBER
                   
                   # CLASSIFICATION NUMBER 
                   class = 1,     # CLASSIFICATION NUMBER
                   
                   # ABSOLUTE CONDITION
                   conditions = "dummy_var >= 3")


# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv2 <- cv.2.rast(r, at$Cell,classVector = cv2, plot = FALSE)
```

<a id="figure6"></a>

```{r cond_4_nofn2_plot, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# CLASS VECTOR LEVELS
unique(cv2)

# class = 0,  focal cell
# class = 1,  cell with values 'dummy_var >= 3'
# class = NA, unclassified cells

# PLOT THE CLASS VECTOR
par(mar = c(0.1, 2, 0.5, 0.1))
plot(r_cv2, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 6 -** Classification using the function **cond.4.nofn** and the rule `conditions = "dummy_var >= 3"`. In **light blue**, the initial focal cell; in **brown** cell meeting function conditions; in **grey**, unclassified cells. Only **cells contiguous AND continuous** to the focal cell with values `>=3` are identified by the function.</span></div>

---

[Absolute neighborhood condition](scapesClassification_01_3_ClassRules.html#absolute-conditions) are flagged by a variable name followed by curly brackets (`{}`). They compare the values of the test cell and of its neighborhood against a threshold value. Test cells are classified if the rule is true for at least as many evaluations as the ones specified by the argument `fn_perc`. 

In the following example we will use the function `cond.4.nofn()` with the arguments `conditions = "dummy_var{} >= 3"` and  `fn_perc = 1`. This means that the function will identify ([Figure 7](#figure7)):

* cells whose value is `>= 3`;  

* _AND_ whose all (`fn_perc = 1`) neighbor values are `>= 3`;

* _AND_ that are contiguous and continuous to the focal cell.

```{r cond_4_nofn3, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# COMPUTE THE CLASS VECTOR (ABSOLUTE NEIGHBORHOOD CONDITION)
cv3 <- cond.4.nofn(attTbl = at, 
                   ngbList = nbs, 
                   
                   # CLASS VECTOR - INPUT
                   classVector = at$cv, 
                   
                   nbs_of = c(0,  # FOCAL CELL CLASS
                              1), # CLASSIFICATION NUMBER
                   
                   # CLASSIFICATION NUMBER 
                   class = 1,     # CLASSIFICATION NUMBER
                   
                   # ABSOLUTE NEIGHBORHOOD CONDITION
                   conditions = "dummy_var{} >= 3",
                   
                   # RULE HAS TO BE TRUE FOR AT LEAST 100% OF THE EVALUATIONS
                   fn_perc = 1)


# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv3 <- cv.2.rast(r, at$Cell,classVector = cv3, plot = FALSE)
```

<a id="figure7"></a>

```{r cond_4_nofn3_plot, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# CLASS VECTOR LEVELS
unique(cv3)

# class = 0,  focal cell
# class = 1,  cell with values 'dummy_var >= 3'
# class = NA, unclassified cells

# PLOT THE CLASS VECTOR
par(mar = c(0.1, 2, 0.5, 0.1))
plot(r_cv3, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 7 -** Classification using the function **cond.4.nofn**, the rule `conditions = "dummy_var{} >= 3"` and the argument `fn_perc = 1`. In **light blue**, the initial focal cell; in **brown** cell meeting function conditions; in **grey**, unclassified cells. Only cells with values `>=3`, with neighboring cells with values `>=3` and continuous with the focal cell are identified by the function.</span></div>

---

[Relative conditions](scapesClassification_01_3_ClassRules.html#relative-conditions) compare the values of contiguous cells. Relative focal cell conditions are flagged by a variable name followed by square brackets (`[]`) and compare the value of the test cell against the value of the focal cell. 

Note that if class continuity is considered, the pool of focal cells will change at each new iteration. Cell classified at one iteration will serve as focal cells in the next iteration (see [class continuity](scapesClassification_01_2_RuleEvaluation.html#class-continuity)). 

In the following example we will use the function `cond.4.nofn()` with the argument `conditions = "dummy_var > dummy_var[]"`. This means that the function will identify test cells with `dummy_var` values greater than the focal cell value (`dummy_var[]`) ([Figure 8](#figure8)): 

```{r cond_4_nofn4, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# COMPUTE THE CLASS VECTOR (RELATIVE FOCAL CELL CONDITION)
cv4 <- cond.4.nofn(attTbl = at, 
                   ngbList = nbs, 
                   
                   # CLASS VECTOR - INPUT
                   classVector = at$cv, 
                   
                   nbs_of = c(0,  # FOCAL CELL CLASS
                              1), # CLASSIFICATION NUMBER
                   
                   # CLASSIFICATION NUMBER 
                   class = 1,     # CLASSIFICATION NUMBER
                   
                   # RELATIVE FOCAL CELL CONDITION
                   conditions = "dummy_var > dummy_var[]")


# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv4 <- cv.2.rast(r, at$Cell,classVector = cv4, plot = FALSE)
```

<a id="figure8"></a>

```{r cond_4_nofn4_plot, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# CLASS VECTOR LEVELS
unique(cv4)

# class = 0,  focal cell
# class = 1,  cells with values greater than the value of the focal cell
# class = NA, unclassified cells

# PLOT THE CLASS VECTOR
par(mar = c(0.1, 2, 0.5, 0.1))
plot(r_cv4, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 8 -** Classification using the function **cond.4.nofn** and the rule `conditions = "dummy_var > dummy_var[]"`. In **light blue**, the initial focal cell; in **brown** cell meeting function conditions; in **grey**, unclassified cells. Note that at the 1^st^ iteration there are only two cells contiguous to the focal cell and with values `>3` (brown cells with values `=5`). In the 2^nd^ iteration the two brown cells of value 5 become focal cells; among their neighbors there is only one cell with a value `>5` (the brown cell with value `=10`). Among the neighbors of the brown cell of value 10, none has values `>10`. Therefore the function stops after the 2^nd^ iteration.</span></div>

---

[Relative neighborhood conditions](scapesClassification_01_3_ClassRules.html#relative-conditions) are flagged by a variable name followed by square brackets (`{}`). They compare the value of the test cell against the values of its neighborhood. Test cells are classified if the rule is true for at least as many evaluations as the ones specified by the argument `fn_perc`. 

In the following example we will use the function `cond.4.nofn()` with the arguments `conditions = "dummy_var > dummy_var{}"` and  `fn_perc = 0.6`. This means that the function will identify ([Figure 9](#figure9)):

* cells whose value is greater than 60% of its neighbors;  

* _AND_ that are contiguous and continuous to the focal cell.

For neighborhoods of 8 cells, `fn_perc = 0.6` means that the value of the test cell has to be `>` than at least 5 of its neighbors. 

```{r cond_4_nofn5, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# COMPUTE THE CLASS VECTOR (RELATIVE NEIGHBORHOOD CONDITION)
cv5 <- cond.4.nofn(attTbl = at, 
                   ngbList = nbs, 
                   
                   # CLASS VECTOR - INPUT
                   classVector = at$cv, 
                   
                   nbs_of = c(0,  # FOCAL CELL CLASS
                              1), # CLASSIFICATION NUMBER
                   
                   # CLASSIFICATION NUMBER 
                   class = 1,     # CLASSIFICATION NUMBER
                   
                   # RELATIVE NEIGHBORHOOD CONDITION
                   conditions = "dummy_var > dummy_var{}",
                   
                   # RULE HAS TO BE TRUE FOR AT LEAST 60% OF THE EVALUATIONS
                   fn_perc = 0.6)


# CONVERT THE CLASS VECTOR INTO A RASTER
r_cv5 <- cv.2.rast(r, at$Cell, classVector = cv5, plot = FALSE)
```

<a id="figure9"></a>

```{r cond_4_nofn5_plot, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# CLASS VECTOR LEVELS
unique(cv5)

# class = 0,  focal cell
# class = 1,  cells with values greater than the value of 60% of their neighbors
# class = NA, unclassified cells

# PLOT THE CLASS VECTOR
par(mar = c(0.1, 2, 0.5, 0.1))
plot(r_cv5, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", col=c("#78b2c4", "#cfad89"))
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 9 -** Classification using the function **cond.4.nofn**, the rule `conditions = "dummy_var > dummy_var{}"` and the argument `fn_perc = 0.6`. In **light blue**, the initial focal cell; in **brown** cell meeting function conditions; in **grey**, unclassified cells. Note that in brown are only cells that present: (i) values greater than the values of 5 or more of their neighbors; (ii) continuity with the initial focal cell.</span></div>

### cond.reclass

The function `cond.reclass()` evaluates conditions for cells of a class and reclassify them if conditions are true. It can consider [absolute conditions](scapesClassification_01_3_ClassRules.html#absolute-conditions) and [relative neighborhood conditions](scapesClassification_01_3_ClassRules.html#relative-conditions). 

In the following example we will use the function `cond.reclass()` with the argument `conditions = "dummy_var{} >= 3"`. The class vector computed in the last example (`cv5` - [Figure 9](#figure9)) will be used as a function input. This class vector has classes `0` (initial focal cell) and `1` (classified cells). Cells of class 1 will be reclassified if their value and the value of all their neighbors is `>=3` (`conditions = "dummy_var{} >= 3"`; `fn_perc = 1`)([Figure 10](#figure10)).

```{r cond_reclass1, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# RECLASSIFY
cr <- cond.reclass(attTbl = at, 
                   ngbList = nbs, 
                    
                   # CLASS VECTOR COMPUTED WITH THE RULE "dummy_var > dummy_var{}"
                   classVector = cv5,
                   
                   # CELLS TO RECLASSIFY HAVE THIS CLASS
                   class = 1,
                   
                   # CELL MEETING CONDITIONS OF CLASS = 1 ARE RECLASSIFIED 
                   conditions = "dummy_var{} >= 3",
                    
                   # NEW CLASSIFICATION NUMBER
                   reclass = 2,
                   
                   # RULE HAS TO BE TRUE FOR AT LEAST 100% OF THE EVALUATIONS
                   fn_perc = 1)


r_cr <- cv.2.rast(r, at$Cell,classVector = cr, plot = FALSE)
```

<a id="figure10"></a>

```{r cond_reclass1_plot, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# CLASS VECTOR LEVELS
unique(cr)

# class = 0,  focal cell
# class = 1,  cells with values greater than the value of 60% of their neighbors
# class = 2,  reclassified cells
# class = NA, unclassified cells

# PLOT THE CLASS VECTOR
par(mar = c(0.1, 2, 0.5, 0.1))
plot(r_cr, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", 
     col=c("#78b2c4", "#cfad89", "#1088a0"))
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 10 -** Cells classified in [figure 9](#figure9) and belonging to `class 1` are reclassified using the function **cond.reclass**, the rule `conditions = "dummy_var{} >= 3"` and the argument `fn_perc = 1`. In **light blue**, the initial focal cell; in **brown**, cell classified in [figure 9](#figure9); in **dark blue**, reclassified cell; in **grey**, unclassified cells. Cells are reclassified if their value and the value of all their neighbors is `>=3`.</span></div>

## Neighbor only functions

**Functions:** `reclass.nbs()` and `classify.all()`.

Neighbor only functions are based only on class contiguity and continuity and do not present the argument `conditions`. Classifications performed by these functions are based on [focal evaluations](scapesClassification_01_2_RuleEvaluation.html#focal-evaluation) and only take into account the spatial relationships existing among different groups of cells. 

### reclass.nbs

The function `reclass.nbs()` evaluates if members of two classes are contiguous and, if they are, one of them is reclassified. 

In the following two examples we will use the class vector computed in [figure 9](#figure9) (`cv5`) as a function input. This class vector has classes `0` (initial focal cell) and `1` (classified cells). Cells of class `1` adjacent to the initial focal cell (class `0`) will be reclassified as cells of class `2` ([Figure 11](#figure11)). 

* In the 1^st^ example we use the argument `reclass_all = FALSE`, only cells of class `1` contiguous to the focal cell (class `0`) are reclassified as cells of class `2` ([Figure 11 - Left panel](#figure11)); 

```{r reclass_nbs1, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# RECLASSIFY NEIGHBORS
cv_rec1 <- reclass.nbs(attTbl = at, 
                       ngbList = nbs, 
                     
                       # CLASS VECTOR COMPUTED WITH THE RULE "dummy_var > dummy_var{}"
                       classVector = cv5,
                     
                       # CELLS OF CLASS...
                       class = 1,
                     
                       # ...ADJACENT TO CELLS OF ANOTHER CLASS... 
                       nbs_of = 0,
                     
                       # ...WILL BE RECLASSIFIED...
                       reclass = 2, 
                       
                       # NO MORE RECLASSIFICATIONS
                       reclass_all = FALSE)


r_cv_rec1 <- cv.2.rast(r, at$Cell,classVector = cv_rec1, plot = FALSE)
```

* In the 2^nd^ example we use the argument `reclass_all = TRUE`, cells of class `1` contiguous to the focal cell (class `0`) are reclassified as cells of class `2`; all cells of class `1` connected to a reclassified cell are also reclassified ([Figure 11 - Right panel](#figure11)). 

```{r reclass_nbs2, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# RECLASSIFY NEIGHBORS
cv_rec2 <- reclass.nbs(attTbl = at, 
                       ngbList = nbs, 
                     
                       # CLASS VECTOR COMPUTED WITH THE RULE "dummy_var > dummy_var{}"
                       classVector = cv5,
                     
                       # CELLS OF CLASS...
                       class = 1,
                     
                       # ...ADJACENT TO CELLS OF ANOTHER CLASS... 
                       nbs_of = 0,
                     
                       # ...WILL BE RECLASSIFIED...
                       reclass = 2, 
                       
                       # ...AND SO ALL CELLS OF CLASS 1 CONNECTED TO A RECLASSIFIED CELL
                       reclass_all = TRUE)


r_cv_rec2 <- cv.2.rast(r, at$Cell,classVector = cv_rec2, plot = FALSE)
```

<a id="figure10"></a>

```{r reclass_nbs_plot, message=FALSE, warning=FALSE, echo=TRUE, collapse=TRUE}
# CLASS VECTOR LEVELS
unique(cv_rec1) # ONLY CELLS ADJACENT TO THE FOCAL CELL ARE RECLASSIFIED

unique(cv_rec2) # ALL CELL ARE RECLASSIFIED

# class = 0,  focal cell
# class = 1,  cells with values greater than the value of 60% of their neighbors
# class = 2,  reclassified cells
# class = NA, unclassified cells

# PLOT THE CLASS VECTOR
par(mar = c(0.1, 0.1, 0.1, 0.1), par(mfrow=c(1,2)))
plot(r_cv_rec1, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", 
     col=c("#78b2c4", "#cfad89", "#1088a0"))
text(r)

plot(r_cv_rec2, axes=FALSE, box=FALSE, legend = FALSE, colNA="#818792", 
     col=c("#78b2c4", "#cfad89", "#1088a0"))
text(r)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 11 -** Reclassify cells using the function **reclass.nbs**. **On the left**, cells classified in [figure 9](#figure9) are reclassified it they are adjacent to the initial focal cell. In **brown**, cell classified in [figure 9](#figure9); in **light blue**, the initial focal cell; in **dark blue**, reclassified cell; in **grey**, unclassified cells. **On the right**, argument `reclass_all = TRUE`, all cells classified in [figure 9](#figure9) connected to a reclassified cell are also reclassified. In this case all cells are reclassified (no more brown cells).</span></div>
