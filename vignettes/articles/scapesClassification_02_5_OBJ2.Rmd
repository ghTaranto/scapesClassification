---
title: "Raster object manipulation"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Raster object manipulation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width = "100%", echo = TRUE)
```

# RU-objects

In the previous article we identified a set of relief unit objects (RU-objects) ([independent objects on raster surfaces](scapesClassification_02_4_OBJ.html)). These objects correspond to prominent seamounts, banks and ridges. In this article we will see how raster objects can be manipulated using the attribute table.

# Load data and libraries

We will start by loading the required libraries and data into the workspace. These steps were explained in the previous articles: [format input data](scapesClassification_02_1_DATA.html), [island shelf unit (ISU)](scapesClassification_02_2_ISU.html), [local maxima on gridded data](scapesClassification_02_3_PKS.html) and [independent objects on raster surfaces](scapesClassification_02_4_OBJ.html):

```{r loadLD, message=FALSE, warning=FALSE, collapse = TRUE}
# LOAD LIBRARIES
library(raster)
library(scapesClassification)

# LOAD DATA
grd <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T)
grd <- grd[grepl("\\.grd", grd)]
grd <- grd[!grepl("hillshade", grd)]
rstack <- stack(grd)

# COMPUTE ATTRIBUTE TABLE
atbl <- attTbl(rstack, var_names = c("bathymetry", "gmorph", "local_bpi", "regional_bpi", "sd_bat", "slope"))

# COMPUTE NEIGHBORHOOD LIST
nbs <- ngbList(rstack, rNumb = TRUE, attTbl = atbl) # neighbors are identified by their row number in the attribute table

# LOAD PEAK CLASSIFICATION
PKS <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T, 
                  pattern = "Peak_Cells\\.RDS")

atbl$PKS <- readRDS(PKS)

# LOAD RU_OBJECT CLASSIFICATION
RU_OBJ2 <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T, 
                      pattern = "RU_obj2\\.RDS")

atbl$RU_OBJ2 <- readRDS(RU_OBJ2)
```

The R package [`data.table`](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html) provides an easy syntax for manipulating tabular data. We will use it to manipulate the RU-objects stored in the attribute table.

```{r data_table, message=FALSE, warning=FALSE, collapse = TRUE}
# CONVERT "atbl" INTO A DATA TABLE
library(data.table)
atbl <- as.data.table(atbl)
```

```{r loadMapView, message=FALSE, include=FALSE}
library(mapview)
library(leaflet)
library(leafem)

# set gerenal options 
mapviewOptions(basemaps = c("Esri.OceanBasemap", "OpenStreetMap"), na.color = "grey88", homebutton = FALSE, 
               query.position = "bottomright", legend.opacity = 0.9)

# hillShade
hs <- list.files(system.file("extdata", package = "scapesClassification"), full.names = T)
hs <- raster(hs[grepl("hillshade\\.grd", hs)])

# set palettes
palRYB <- c("#2892c7", "#fafa64", "#e81014")
palYGB <- c("#ffff80" ,"#3dba65", "#0d1178")
palBYR <- c("#4575b5", "#ffffbf", "#d62f27")
gm_col <- c("grey70", "#380000", "#c80000", "#ff5014", "#fad23c", "#ffff3c", "#b4e614", "#3cfa96", "#0000ff", "#000038")
```

# RU-object BPI

The bathymetric position index (BPI) quantifies where a location on a bathymetric surface is relative to the overall seascape ([Walbridge et al., 2018](https://www.mdpi.com/2076-3263/8/3/94/htm)). It is computed as the bathymetric difference between a cell located at the center of a neighborhood and the average depth of the neighborhood. The resulting values are positive near crests and ridges, and negative near cliff bases and valley bottoms. 

The neighborhood used to compute BPI surfaces are user defined. If we consider that each RU-object define one neighborhood, then we can compute object-specific BPI surfaces. Object-specific BPI surfaces are useful to distinguish among different portions of a feature (e.g., top or bottom portions).

```{r ru_bpi, message=FALSE, warning=FALSE, collapse = TRUE}
atbl[!is.na(RU_OBJ2), ':=' (RU_BPI = (bathymetry - mean(bathymetry))/sd(bathymetry)), by = "RU_OBJ2"]
```

As an example we will show the BPI values of units 2 and 12 ([Figure 1](#figure1)). 

```{r bpi_2_12, message=FALSE, warning=FALSE, collapse = TRUE}
BPI_RU2 <- atbl$RU_BPI
BPI_RU2[!(atbl$RU_OBJ2 %in% c(2))] <- NA

BPI_RU12 <- atbl$RU_BPI
BPI_RU12[!(atbl$RU_OBJ2 %in% c(12))] <- NA

BPI_RU2  <- cv.2.rast(rstack, atbl$Cell, BPI_RU2)
BPI_RU12 <- cv.2.rast(rstack, atbl$Cell, BPI_RU12)
```

<a id="figure1"></a>
```{r bpi_2_12_plot, message=FALSE, warning=FALSE, echo=FALSE}
mapview(hs, col.regions = c("gray0", "gray50", "grey100"), alpha.regions=1, layer.name = "hillshade", legend = FALSE, label = FALSE) +
  mapview(BPI_RU2,  layer.name = "BPI_RU2", col.regions = palBYR,  legend = TRUE, alpha.regions = 0.8, na.color = "transparent") + 
  mapview(BPI_RU12, layer.name = "BPI_RU12", col.regions = palBYR, legend = TRUE, alpha.regions = 0.8, na.color = "transparent") 
```

# Flat tops, ridges and slopes

We will now identify cells within RU-objects corresponding to flat tops, ridges or slopes and we will show the results for units 2 and 12.

### Flat tops
Flat tops are defined here as all the raster cells connected to a peak with `slopes <= 5ยบ`. This rule alone is too permissive and do not allow for a correct classification of flat top areas ([Figure 2](#figure2)). Therefore, we will add a second rule stating that flat tops cells must have `RU_BPI` within the top 20% pf the peak `RU_BPI` value (RU_BPI > RU_BPI)



within the top 20% of the RU_BPI associated to that peak and with slopes <= 5ยบ.



