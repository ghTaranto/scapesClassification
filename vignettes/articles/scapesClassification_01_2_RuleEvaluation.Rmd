---
title: "Rule evaluation"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Rule evaluation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width = "90%", echo = TRUE, fig.align='center', message=FALSE, warning=FALSE)
```


## Global evaluation
___Global evaluation functions:___ `cond.4.all()`. 

Classification rules are applied to all raster cells regardless of their position ([Figure 1](#figure1)). 

<a id="figure1"></a>

```{r v_eval, message=FALSE, warning=FALSE, echo=FALSE, include=FALSE}
library(gifski)
library(ggplot2)
library(reshape2)





vect_eval <- function(){
  
  m  <- matrix(1,nrow = 7, ncol = 7, byrow = TRUE)
  m[1:4,4:7]  <- 10
  m[6:7, 1:5] <- 10
  
  dta <- t(m)[,nrow(m):1]
  dta <- melt(dta)
  # dta <- dta$value
  # 
  # m     <- matrix(1:49, nrow = 7, ncol = 7, byrow = TRUE)
  # cnumb <- t(m)[,nrow(m):1] 
  # cnumb <- melt(cnumb)
  # cnumb <- cnumb$value
  
  dta$cls[dta$value>1] <- 1
  
  dta$cls <- as.factor(dta$cls)
  dta$value <- as.factor(dta$value)
  dta$blank <- as.factor(NA)
  
  p <- ggplot(dta, aes(x=Var1, y=Var2)) +
    geom_tile(aes(fill=blank), colour="gray90", lwd=1.5, show.legend = FALSE) +
    coord_fixed(ratio=1) + 
    geom_text(aes(label=value), color = "white", family=c("serif"), size=9) + 
    scale_fill_manual(values = c("#1088a0", "goldenrod3"), na.value = "black") + 
    theme_void()
  
  print(p)
  
  p <- ggplot(dta, aes(x=Var1, y=Var2)) +
    geom_tile(aes(fill=cls), colour="gray90", lwd=1.5, show.legend = FALSE) +
    coord_fixed(ratio=1) + 
    geom_text(aes(label=value), color = "white", family=c("serif"), size=9) + 
    scale_fill_manual(values = c("#1088a0", "goldenrod3"), na.value = "black") + 
    theme_void()
  
  print(p)
  
}

gifski::save_gif(vect_eval(), "v_eval.gif", delay = 2.8, width = 800, 
                 height = 800, progress = FALSE, loop = TRUE)
```

```{r g_eval, message=FALSE, warning=FALSE, echo=FALSE}
library(scapesClassification)
library(terra)

# base rasters 
m  <- matrix(1,nrow = 7, ncol = 7, byrow = TRUE)
m[1:4,4:7]  <- 10
m[6:7, 1:5] <- 10
r <- terra::rast(m)
r_lg <- r; r_lg[] <- 1

#plot
par(mfrow=c(1,2))
m <- c(1, 1, 1.5, 1)

# 1)
plot(r_lg, type="classes", col="black", ylim=c(-0.1,1.16),axes=FALSE, mar=m,
     plg=list(x=0, y=-0.03, cex=0.9, legend="unclassified", ncol=2))
lines(r, col="white", lwd=2)
text(r, col="white", cex=1.1, family = "sans")
text(x=0, y=1.12, cex=1.5, font=2, adj=0, "Global evaluation", family = "serif")
text(x=0, y=1.03, cex=1.1, font=2, adj=0, "a. Raster data", family = "mono", col="#818792")

# 2)
plot(r, type="classes", col=c("black","#1088a0"), ylim=c(-0.1,1.16),axes=FALSE, mar=m,
     plg=list(x=0, y=-0.03, cex=0.9, legend=c("unclassified","classified"), ncol=2))
lines(r, col="white", lwd=2)
text(r, col="white", cex=1.1, family = "sans")
# text(xyFromCell(r, which(values(r)==1)), col="white", cex=1.1, family = "sans", "1")
# text(xyFromCell(r, which(values(r)!=1)), col="black", cex=1.1, family = "sans", "10")
text(x=0, y=1.03, cex=1.1, font=2, adj=0, "b. Rule: 'cell_value > 1'", family = "mono", col="#818792")


#knitr::include_graphics("v_eval.gif")
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 1 - Global evaluation**. All raster cells are evaluated against the classification rule. **(a)** Before applying the classification rule; **(b)** after applying the classification rule.</span></div>

## Focal evaluation
___Focal evaluation functions:___ `anchor.seed()`, `cond.4.nofn()`, `cond.reclass()`, `reclass.nbs()` and `classify.all()`. 

In other cases it can be more fruitful to perform targeted evaluations with classification rules only tested at specific positions on a raster. These positions are identified based on their adjacency to particular raster cells that we will call **focal cells**. Focal cells can be derived using [anchor cell function](scapesClassification_01_4_ClassFunctions.html#anchor-cell-functions) and can represent: previous classifications, particular environmental or geographic characteristics, local maxima or minima or spatial objects. Focal evaluations take into account _class contiguity_ and _class continuity_. 

### Class contiguity {#cc}
Classification rules are applied only to raster cells in the [neighborhood](scapesClassification_01_1_FormatInputs.html#list-of-neighborhoods) of focal cells ([Figure 2](#figure2)). 

<a id="figure2"></a>
```{r c_contiguity, message=FALSE, warning=FALSE, echo=FALSE, include=FALSE}
library(gifski)

fc_tc <- function(r, fc=25){
  
  fcn <- rbind(c(1/7*2, 1/7*5), c(1/7*5, 1/7*5), c(1/7*5, 1/7*2), c(1/7*2, 1/7*2), c(1/7*2, 1/7*5))
  fcn <- terra::vect(fcn, type="polygons")
  
  r_lg<-r;r_lg[]<-NA;r_lg[1:3]<-1:3
  l0 <- c("focal cell", "test cell", "classified cell")
  
  m <- c(1, 1, 1, 1)
  r_fc<-r;r_fc[]<-NA;r_fc[25]<-1
  
  plot(r_lg, type="classes", col=c("#1088a0","#cfc1af","#818792"),ylim=c(-0.1,1.16),axes=FALSE,mar=m, 
       plg=list(x=0, y=-0.03, cex=1.4, legend=l0, ncol=3))
  plot(r_fc, type="classes", col="#1088a0",colNA="black", ylim=c(-0.1,1.16),axes=FALSE, mar=m,legend=FALSE, add=TRUE)
  lines(r, col="white", lwd=2)
  lines(fcn, col="#1088a0", lwd=2)
  text(x=xFromCell(r, 1:49), y=yFromCell(r, 1:49)-0.04, col="gray", cex=1, family = "sans", values(r))
  text(x=xFromCell(r, 25),y=yFromCell(r, 25)+0.01,col="white", cex=1.5, font=2,family = "sans", "FC")
  text(x=1, y=1.10, cex=2.5, adj=1, font=4, "Class contiguity", family = "serif", col="darkred")
  text(x=0, y=1.03, cex=1.5, font=2, adj=0, "Itr 1.0", family = "mono", col="#818792")
  text(x=1, y=1.03, cex=1.5, adj=1, "Rule: 'cell_value > 1'", family = "mono", col="#818792")
  
  ngb<-ngb8(7,7)[["25"]]
  ord <- c(2,3,5,8,7,6,4,1,0)
  itr <- 0
  
  for(i in ord){
    
    if(i==2){
      tc0      <- NULL
      col_eval <- NULL
    }
    
    if(i!=2){
      tc0 <- c(tc0, tc)
      col_eval[tc0>1] <-"darkgreen"
      col_eval[tc0<=1]<-"darkred"
    }
    
    r_fc[]<-NA;r_fc[25]<-1
    if(i==0){
      tc<-NULL
      col_r <- "#1088a0"
      itr <- "end"
    }else{
      tc<-ngb[i]
      r_fc[tc]<-2
      col_r <- c("#1088a0","#cfc1af")
      itr <- itr+1
    }
    
    subp <- paste0("Itr 1.", itr)
    
    plot(r_lg, type="classes", col=c("#1088a0","#cfc1af","#818792"),ylim=c(-0.1,1.16),axes=FALSE,mar=m, 
         plg=list(x=0, y=-0.03, cex=1.4, legend=l0, ncol=3))
    plot(r_fc, type="classes", col= col_r, colNA="black",ylim=c(-0.1,1.16),axes=FALSE,mar=m,legend=FALSE, add=TRUE)
    lines(r, col="white", lwd=2)
    lines(fcn, col="#1088a0", lwd=2)
    text(x=xFromCell(r, 1:49), y=yFromCell(r, 1:49)-0.04, col="gray", cex=1, family = "sans", values(r))
    text(x=xFromCell(r, 25),y=yFromCell(r, 25)+0.01,col="white", cex=1.5, font=2,family = "sans", "FC")
    if(!is.null(tc)){
      text(x=xFromCell(r, tc),y=yFromCell(r, tc)+0.01,col="white", cex=1.5, font=2,family = "sans", "TC")
    }
    if(!is.null(tc0)){
      col_eval <- ifelse(unlist(r[tc0]) > 1, "darkgreen", "darkred")
      points(x=xFromCell(r, tc0),y=yFromCell(r, tc0)+0.01, pch=20, col=col_eval, cex=3)
    }
    text(x=1, y=1.10, cex=2.5, adj=1, font=4, "Class contiguity", family = "serif", col="darkred")
    text(x=0, y=1.03, cex=1.5, font=2, adj=0, subp, family = "mono", col="#818792")
    text(x=1, y=1.03, cex=1.5, adj=1, "Rule: 'cell_value > 1'", family = "mono", col="#818792")
  }
  
  fc2 <- tc0[which(col_eval == "darkgreen")]
  r_fc[]<-NA;r_fc[25]<-1
  r_fc[fc2]<-2
  
  col_r <- c("#1088a0","#818792")
  
  for(i in 1:3){
    plot(r_lg, type="classes", col=c("#1088a0","#cfc1af","#818792"),ylim=c(-0.1,1.16),axes=FALSE,mar=m, 
           plg=list(x=0, y=-0.03, cex=1.4, legend=l0, ncol=3))
    plot(r_fc, type="classes", col= col_r,colNA="black", ylim=c(-0.1,1.16),axes=FALSE, mar=m,legend=FALSE, add=TRUE)
    lines(r, col="white", lwd=2)
    lines(fcn, col="#1088a0", lwd=2)
    text(x=xFromCell(r, 1:49), y=yFromCell(r, 1:49)-0.04, col="gray", cex=1, family = "sans", values(r))
    text(x=xFromCell(r, 25),y=yFromCell(r, 25)+0.01,col="white", cex=1.5, font=2,family = "sans", "FC")
    col_eval <- ifelse(unlist(r[tc0]) > 1, "darkgreen", "darkred")
    points(x=xFromCell(r, tc0),y=yFromCell(r, tc0)+0.01, pch=20, col=col_eval, cex=3)
    text(x=1, y=1.10, cex=2.5, adj=1, font=4, "Class contiguity", family = "serif", col="darkred")
    text(x=0, y=1.03, cex=1.5, font=2, adj=0, subp, family = "mono", col="#818792")
    text(x=1, y=1.03, cex=1.5, adj=1, "Rule: 'cell_value > 1'", family = "mono", col="#818792")
  }
}

gifski::save_gif(fc_tc(r), "fc_tc.gif", delay = 0.8, width = 700, 
                 height = 700, progress = FALSE, loop = TRUE)
```

```{r gif1, message=FALSE, warning=FALSE, echo=FALSE, out.width = "80%"}
knitr::include_graphics("fc_tc.gif")
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 2 - Class contiguity**. Classification rule applied only to test cells in the neighborhoods of focal cells. Positive evaluations are showed in dark green; negative evaluation in dark red.</span></div>


### Class continuity 

Test cells classified in one iteration become the focal cells of the next iteration. In this way, cells that respect the same rule(s) and that are connected to the same focal cells are joined into the same class ([Figure 3](#figure3)).

<a id="figure3"></a>

```{r c_continuity, message=FALSE, warning=FALSE, echo=FALSE, include=FALSE}
ccont <- function(r, fc=25){
  
  r_lg<-r;r_lg[]<-NA;r_lg[1:3]<-1:3
  l0 <- c("focal cell", "classified cell", "unclassified cell")
  
  m <- c(1, 1, 1, 1)
  r_fc<-r;r_fc[]<-NA;r_fc[25]<-1
  
  plot(r_lg, type="classes", col=c("#1088a0","#818792","black"),ylim=c(-0.1,1.16),axes=FALSE,mar=m, 
       plg=list(x=0, y=-0.03, cex=1.4, legend=l0, ncol=3))
  plot(r_fc, type="classes", col="#1088a0",colNA="black", ylim=c(-0.1,1.16),axes=FALSE, mar=m,legend=FALSE, add=TRUE)
  lines(r, col="white", lwd=2)
  # lines(fcn, col="#1088a0", lwd=2)
  text(x=xFromCell(r, 1:49), y=yFromCell(r, 1:49)-0.04, col="gray", cex=1, family = "sans", values(r))
  text(x=1, y=1.10, cex=2.5, adj=1, font=4, "Class continuity", family = "serif", col="darkred")
  text(x=0, y=1.03, cex=1.5, font=2, adj=0, "Itr 0.0", family = "mono", col="#818792")
  text(x=1, y=1.03, cex=1.5, adj=1, "Rule: 'cell_value > 1'", family = "mono", col="#818792")
  
  FC0 <- 25
  FC  <- 25
  tc0 <- NULL
  col_eval <- NULL
  
  itr <- 1
  while (itr<=3) {
    
    tc  <- unlist(ngb8(7,7)[FC])
    tc0 <- unique(c(tc, tc0))
    
    if(25 %in% tc0){
      tc0 <- tc0[-which(tc0==25)]
    }
    
    col_eval <- unlist(r[tc0]) > 1
    
    r_fc<-r;r_fc[]<-NA
    r_fc[tc0[col_eval]] <- 2
    r_fc[FC0]<-1
    col_eval <- ifelse(col_eval, "darkgreen", "darkred")
    
    subp <- paste0("Itr ", itr, ".0")
    
    plot(r_lg, type="classes", col=c("#1088a0","#818792","black"),ylim=c(-0.1,1.16),axes=FALSE,mar=m, 
         plg=list(x=0, y=-0.03, cex=1.4, legend=l0, ncol=3))
    plot(r_fc, type="classes", col=c("#1088a0","#818792"), colNA="black",ylim=c(-0.1,1.16),axes=FALSE,
         mar=m,legend=FALSE, add=TRUE)
    lines(r, col="white", lwd=2)
    # lines(fcn, col="#1088a0", lwd=2)
    text(x=xFromCell(r, 1:49), y=yFromCell(r, 1:49)-0.04, col="gray", cex=1, family = "sans", values(r))
    points(x=xFromCell(r, tc0),y=yFromCell(r, tc0)+0.01, pch=20, col=col_eval, cex=3)
    text(x=1, y=1.10, cex=2.5, adj=1, font=4, "Class continuity", family = "serif", col="darkred")
    text(x=0, y=1.03, cex=1.5, font=2, adj=0, subp, family = "mono", col="#818792")
    text(x=1, y=1.03, cex=1.5, adj=1, "Rule: 'cell_value > 1'", family = "mono", col="#818792")
    
    itr <- itr+1
    
    tc <- tc[unlist(r[tc]) > 1]
    FC  <- tc
    
  }
}
  
gifski::save_gif(ccont(r), "ccont.gif", delay = 1.5, width = 700, 
                 height = 700, progress = FALSE, loop = TRUE)
```

```{r gif3, message=FALSE, warning=FALSE, echo=FALSE, out.width = "80%"}
knitr::include_graphics("ccont.gif")
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 4 - Class continuity.** Classification rule applied only to test cells in the neighborhoods of focal cells. Test cells classified in one iteration become focal cells in the next iteration. Positive evaluations are showed in dark green; negative evaluation in dark red.</span></div>
