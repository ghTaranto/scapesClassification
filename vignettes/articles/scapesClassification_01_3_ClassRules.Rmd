---
title: "Classification rules"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Classification rules}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width = "99%", echo = TRUE, fig.align='center', message=FALSE, warning=FALSE)
```

In `scapesClassification`, geo-spaces are classified using user-defined classification rules presented in the form of [conditional statements](https://en.wikipedia.org/wiki/Conditional_(computer_programming) "Wikipedia definition"). Classification rules evaluate either to true or false and determine, at each classification step, what raster cells are mapped to a class.  

Classifications start by converting single and multi-layer raster objects into [attribute tables](scapesClassification_01_1_FormatInputs.html#attribute-table). Each column of the attribute table represents a variable and contains the values of a raster layer. Classification rules can be built accessing by name the variables stored in the attribute table. For instance, if our attribute table has two columns named `"slope"` and `"height"` we could build the following classification rule: `"slope > 5 & height > 1000"`. 

Rules are passed to a scapesClassification function as a single **`character string`**. They consist of combination of arithmetic (`+|-|*|/|^|%%|%/%`), relational (`>|<|>=|<=|==|!=|%/%`) and logic operators (`&||`), base R functions (e.g., `abs(variable_name)`), variables names (i.e., `names(attTbl)`) and previous classifications (either stored as `"classVector"` or as rasters) (see `?conditions`). 

## Definitions

The different types of classification rules used by `scapesClassification` can be better explained considering [Figure 1](#figure1) and the following definitions: 

* **Cell neighborhood.** The neighborhood of a raster cell with coordinates `(x, y)` counts 8 neighbors with coordinates `(x±1, y)`,  `(x, y±1)` and `(x±1, y±1)`. Note that edge cells have less than 8 neighbors (see ["Format inputs"](scapesClassification_01_1_FormatInputs.html#list-of-neighborhoods)). _In [Figure 1](#figure1) are presented the focal and the test cells neighborhoods_.

* **Focal cell.** Cell identified by a particular class. Cells in the neighborhood of a focal cell are evaluated against the classification rule(s). _In [Figure 1](#figure2) there is one focal cell, cell number 25._  

* **Test cell.** The cell in the neighborhood of the focal cell that is being tested. At turns all cells in the neighborhood of a focal cell are tested against the classification rule(s). _In [Figure 1](#figure1) the cell being tested is cell 17._  

* **Directional neighborhood.** It consists of the intersection between the focal and the test cell neighborhoods. _In [Figure 1](#figure1) it is marked by a red border and includes cells `17, 18, 24, 25`._  

<a id="figure1"></a>

```{r def, message=FALSE, warning=FALSE, echo=FALSE}
library(ggplot2)
library(reshape2)
library(scapesClassification)
library(raster)

m     <- matrix(1:49, nrow = 7, ncol = 7, byrow = TRUE)

r   <- raster(m)
nbs <- ngbList(r)

m <- t(m)[,nrow(m):1]
m_long <- melt(m)

m_long$tags[m_long$value == 25] <- "FC"
m_long$tags[m_long$value == 17] <- "TC"

npool <- unique(unlist(nbs[c("25", "17")]))
m_long$whites[m_long$value %in% npool] <- m_long$value[m_long$value %in% npool]


m_long$tags <- as.factor(m_long$tags)


p <- ggplot(m_long, aes(x=Var1, y=Var2)) +
  geom_tile(aes(fill=tags), colour="gray90", lwd=1.5, show.legend = FALSE) +
  coord_fixed(ratio=1) + 
  geom_text(aes(label=value), color = "grey30", family=c("serif"), size=8) + 
  geom_text(aes(label=whites), color = "white", family=c("serif"), size=8) + 
  scale_fill_manual(values = c("#1088a0", "goldenrod3"), na.value = "black") + 
  geom_rect(aes(xmin = 2.5, xmax = 5.5, ymin = 2.5, ymax = 5.5), fill = "transparent", color="#1088a0", lwd = 1.5) + 
  geom_rect(aes(xmin = 1.5, xmax = 4.5, ymin = 3.5, ymax = 6.5), fill = "transparent", color="goldenrod3", lwd = 1.5) +
  geom_rect(aes(xmin = 2.56, xmax = 4.44, ymin = 3.56, ymax = 5.44), fill = "transparent", color="red", lwd = 1.4) +
  theme_void()  + 
  scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0))

print(p)
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 1** - Raster values correspond to cell numbers (`1:49`). **The focal cell** is cell number 25 (in blue). the **test cell** is cell number 17 (in yellow). **The focal cell neighborhood** is marked by the blue border (cells `17,18,19,24,26,31,32,33`). **The test cell neighborhood** is marked by the yellow border (cells `9,10,11,16,18,23,24,25`). **The directional neighborhood** is marked by the red border (cells `17,18,24,25`).</span></div>

```{r test_plot_function, message=FALSE, warning=FALSE, echo=FALSE}
test_plots <- function(fcells, m, 
                       cond, d = FALSE, mi = +Inf, fnp = 1,
                       title_txt = NULL,
                       plot_cnumb = FALSE, show_itr = FALSE,
                       txt_size = 8){
  
  cnumb <- matrix(1:length(m), nrow = NROW(m), ncol = NCOL(m), byrow = TRUE)
  cnumb      <- t(cnumb)[,nrow(cnumb):1]
  cnumb_long <- reshape2::melt(cnumb)
  
  at <- attTbl(raster::raster(m), "dummy_var")
  nbs <-ngbList(raster::raster(m))
  at$cvec[at$Cell %in% fcells] <- 1
  
  m_long <- t(m)[,nrow(m):1]
  m_long <- reshape2::melt(m_long)
  
  m_long$cnumb <- cnumb_long$value
  m_long$tags[m_long$cnumb %in% fcells]   <- "FC"
  
  if(plot_cnumb){
    
    m_long$whites[m_long$cnumb %in% fcells] <- m_long$cnumb[m_long$cnumb %in% fcells]
    
    p <- ggplot(m_long, aes(x=Var1, y=Var2)) +
      geom_tile(aes(fill=tags), colour="gray90", lwd=1.5, show.legend = FALSE) +
      coord_fixed(ratio=1) + 
      geom_text(aes(label=cnumb), color = "grey50", family=c("serif"), size=txt_size) + 
      geom_text(aes(label=whites), color = "white", family=c("serif"), size=txt_size) +
      scale_fill_manual(values = c("#1088a0"), na.value = "black") + 
      theme_void() + 
      scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0))
    
    if(!is.null(title_txt)){
      
      p <- p + ggplot2::labs(title = title_txt) + 
        theme(plot.title=element_text(size = 16, face = "bold", color = "black", family = "serif")) 
    }
    
  } 
  
  if(!show_itr & !plot_cnumb) {
    
    cvec <- cond.4.nofn(at, nbs, classVector = at$cvec, nbs_of = 1, conditions = cond, 
                        class = 1, directional = d, max.iter = mi, fn_perc = fnp)
    cvec_cell <- at$Cell[which(!is.na(cvec))]
    
    m_long$whites[m_long$cnumb %in% cvec_cell] <- m_long$value[m_long$cnumb %in% cvec_cell]
    
    m_long$tags[m_long$cnumb %in% cvec_cell] <- "CL"
    m_long$tags[m_long$cnumb %in% fcells]    <- "FC"
    
    m_long$tags <- as.factor(m_long$tags)
    m_long$tags <- factor(m_long$tags, levels = c("FC", "CL"))
    
    p <- ggplot(m_long, aes(x=Var1, y=Var2)) +
      geom_tile(aes(fill=tags), colour="gray90", lwd=1.5, show.legend = FALSE) +
      coord_fixed(ratio=1) + 
      geom_text(aes(label=value), color = "grey50", family=c("serif"), size=txt_size) + 
      geom_text(aes(label=whites), color = "white", family=c("serif"), size=txt_size) +
      scale_fill_manual(values = c("#1088a0", "#78b2c4"), na.value = "black") + 
      theme_void() + 
      scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0))
    
    if(!is.null(title_txt)){
      
      p <- p + ggplot2::labs(title = title_txt) + 
        theme(plot.title=element_text(size = 16, face = "bold", color = "black", family = "serif")) 
    }
    
  } 
  
  if(show_itr){
    itr <- 0
    continue <- TRUE
    
    l_plot <- list()
    
    while(continue){
      
      cvec_cell <- at$Cell[which(!is.na(at$cvec))]
      
      m_long$whites[m_long$cnumb %in% cvec_cell] <- m_long$value[m_long$cnumb %in% cvec_cell]
      
      m_long$tags[m_long$cnumb %in% cvec_cell] <- "CL"
      m_long$tags[m_long$cnumb %in% fcells]    <- "FC"
      
      m_long$tags <- as.factor(m_long$tags)
      m_long$tags <- factor(m_long$tags, levels = c("FC", "CL"))
      
      p <- ggplot(m_long, aes(x=Var1, y=Var2)) +
        geom_tile(aes(fill=tags), colour="gray90", lwd=1.5, show.legend = FALSE) +
        coord_fixed(ratio=1) + 
        geom_text(aes(label=value), color = "grey50", family=c("serif"), size=txt_size) + 
        geom_text(aes(label=whites), color = "white", family=c("serif"), size=txt_size) +
        scale_fill_manual(values = c("#1088a0", "#78b2c4"), na.value = "black") + 
        theme_void() + 
        scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0))
      
      if(!is.null(title_txt)){
        
        p <- p + ggplot2::labs(title = title_txt) + 
          theme(plot.title=element_text(size = 16, face = "bold", color = "black", family = "serif")) 
        
      } else {
        
        p <- p + ggplot2::labs(title = paste0("Iteration: ", itr)) + 
          theme(plot.title=element_text(size = 16, face = "bold", color = "black", family = "serif")) 
      }
      
      l_plot[[paste0("itr_", itr)]] <- p
      
      cv_test <- cond.4.nofn(at, nbs, classVector = at$cvec, nbs_of = 1, conditions = cond, 
                             class = 1, directional = d, max.iter = 1, fn_perc = fnp)
      
      if( sum(cv_test == 1, na.rm = TRUE) == sum(at$cv == 1, na.rm = TRUE) ){
        continue <- FALSE
      } else {
        at$cvec <- cv_test
      }
      
      itr <- itr + 1
      
    }
    
    p <- l_plot
    
  }
  
  return(p)
  
}
```

```{r test_plot_matrix, message=FALSE, warning=FALSE, echo=FALSE}
m  <- matrix(1,nrow = 7, ncol = 7, byrow = TRUE)
r   <- raster(m)
nbs <- ngbList(r)
# nbs <- nbs_m

r[20] <- 10

n1 <- nbs[["20"]]
r[n1] <- 5

n2 <- setdiff(unique(unlist(nbs[n1])), n1)
r[n2] <- 3

r[20] <- 10
r[c(34,35)] <- 2
####

r[43] <- 8
n1 <- nbs[["43"]]
r[n1] <- 5

n2 <- setdiff(unique(unlist(nbs[n1])), n1)
r[n2] <- 2
r[43] <- 8

m <- as.matrix(r)
```

## Types of classification rules

In the following sections are introduced the types of rules that can be considered by `scapesClassification` functions. Additional information can be found in the documentation of the function `conditions()` and in the article ["Classification functions"]().

The dummy raster of [figure 2](#figure2) will be used to illustrate the different types of classification rules. 

<a id="figure2"></a>

```{r figure2, message=FALSE, warning=FALSE, echo=FALSE}
library(ggpubr)

p1 <- test_plots(fcells = 32, m, cond = FALSE, plot_cnumb = TRUE, title_txt = "Cell numbers", txt_size = 7)
p2 <- test_plots(fcells = 32, m, cond = FALSE, title_txt = "Raster layer: 'dummy_var'", txt_size = 7)

pn <- NULL
 
ggarrange(p1, pn, p2, nrow = 1, widths = c(1,0.1,1))
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 2 -** Example of a raster object. On the left, raster cell numbers; on the right raster data (included in the attribute table with the name `'dummy_var'`). The initial anchor cell is in blue.</span></div>

### Absolute conditions

Absolute conditions compare a test cell against a user-defined threshold value. 


There are two types of absolute conditions:

**1) Test cell rule.** Compares the _test cell_ value against a threshold value ([Figure 3](#figure3));

**2) Test cell neighborhood rule.** Compares the values of the cells in the _test cell neighborhood_ against a threshold value. The argument of the classification functions `fn_perc` determines the percentage of cells in the neighborhood for which the condition has to be true for the final evaluation to be positive ([Figure 3](#figure3)). 

<a id="figure3"></a>

```{r figure3a, message=FALSE, warning=FALSE, echo=FALSE}
p1 <- test_plots(fcells = 32, m, cond = "dummy_var >= 3", mi = 1,
                 title_txt = "Test cell rule", txt_size = 7)

p2 <- test_plots(fcells = 32, m, cond = "dummy_var{} >= 3", fnp = 0.6, mi = 1,
                 title_txt = "Test cell neighborhood rule (tag {})", txt_size = 7)

p1 <- p1 + labs(subtitle = "Rule: dummy_var >= 3 \nfn_perc = N/A") +
  theme(plot.subtitle=element_text(size = 12, color = "black", 
                                family = "serif"))

p2 <- p2 + labs(subtitle = "Rule: dummy_var{} >= 3 \nfn_perc = 60%") +
  theme(plot.subtitle=element_text(size = 12, color = "black", 
                                family = "serif"))

ggarrange(p1, pn, p2, nrow = 1, widths = c(1,0.1,1))
```


Absolute, test cell neighborhood condition.


Relative, focal cell condition.


Relative, test cell neighborhood condition.







