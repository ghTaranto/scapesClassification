---
title: "Classification rules"
author: "Gerald H. Taranto"
date: "`r format(Sys.time(), '%a %d, %B, %Y')`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Classification rules}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(out.width = "99%", echo = TRUE, fig.align='center', message=FALSE, warning=FALSE)
```

In `scapesClassification`, geo-spaces are classified using user-defined classification rules presented in the form of [conditional statements](https://en.wikipedia.org/wiki/Conditional_(computer_programming) "Wikipedia definition"). Classification rules evaluate either to true or false and determine what raster cells belong to a class.  

Classification rules access by name the variables stored in the attribute table (see the article [format inputs](scapesClassification_01_1_FormatInputs.html#attribute-table) and `?attTbl`). For instance, the classification rule `"slope > 5 & height > 1000"` would refer to the values stored in the columns `"slope"` and `"height"` and compare them against the respective threshold value.
 
ScapesClassification functions accept rules in the form of **`character string`**. Rules can include a combination of arithmetic (`+|-|*|/|^|%%|%/%`), relational (`>|<|>=|<=|==|!=|%/%`) and logic operators (`&||`), base R functions (e.g., `abs(variable_name)`), variables names (i.e., `names(attTbl)`) and previous classifications (either stored as `"classVector"` or as rasters) (see `?conditions`). 

## Definitions

The different types of classification rules used by `scapesClassification` can be better explained considering [figure 1](#figure1) and the following definitions: 

* **Cell neighborhood.** The neighborhood of a raster cell with coordinates `(x, y)` counts 8 neighbors with coordinates `(x±1, y)`,  `(x, y±1)` and `(x±1, y±1)`. Note that edge cells have less than 8 neighbors (see the article [format inputs](scapesClassification_01_1_FormatInputs.html#attribute-table) and [figure 1](#figure1)).

* **Focal cell.** Cell identified by a particular class. Cells in the neighborhood of a focal cell are evaluated against the classification rule(s). _In [figure 1](#figure2) there is one focal cell, cell number 32._  

* **Test cell.** The cell in the neighborhood of the focal cell that is being tested. At turns all cells in the neighborhood of a focal cell are tested against the classification rule(s). _In [figure 1](#figure1) the cell being tested is cell 25._  

* **Directional neighborhood.** It consists of the intersection between the focal and the test cell neighborhoods. _In [figure 1](#figure1) it is marked by a red border and includes cells `24, 25, 26, 31, 32 and 33`._  

```{r test_plot_function, message=FALSE, warning=FALSE, echo=FALSE}
library(ggplot2)
library(reshape2)
library(scapesClassification)
library(raster)
library(ggpubr)

test_plots <- function(fcells, m, 
                       cond, d = FALSE, mi = +Inf, fnp = 1,
                       title_txt = NULL,
                       plot_cnumb = FALSE, show_itr = FALSE,
                       txt_size = 8){
  
  cnumb <- matrix(1:length(m), nrow = NROW(m), ncol = NCOL(m), byrow = TRUE)
  cnumb      <- t(cnumb)[,nrow(cnumb):1]
  cnumb_long <- reshape2::melt(cnumb)
  
  at <- attTbl(raster::raster(m), "dummy_var")
  nbs <-ngbList(raster::raster(m))
  at$cvec[at$Cell %in% fcells] <- 1
  
  m_long <- t(m)[,nrow(m):1]
  m_long <- reshape2::melt(m_long)
  
  m_long$cnumb <- cnumb_long$value
  m_long$tags[m_long$cnumb %in% fcells]   <- "FC"
  
  if(plot_cnumb){
    
    m_long$whites[m_long$cnumb %in% fcells] <- m_long$cnumb[m_long$cnumb %in% fcells]
    
    p <- ggplot(m_long, aes(x=Var1, y=Var2)) +
      geom_tile(aes(fill=tags), colour="gray90", lwd=1.5, show.legend = FALSE) +
      coord_fixed(ratio=1) + 
      geom_text(aes(label=cnumb), color = "grey50", family=c("serif"), size=txt_size) + 
      geom_text(aes(label=whites), color = "white", family=c("serif"), size=txt_size) +
      scale_fill_manual(values = c("#1088a0"), na.value = "black") + 
      theme_void() + 
      scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0))
    
    if(!is.null(title_txt)){
      
      p <- p + ggplot2::labs(title = title_txt) + 
        theme(plot.title=element_text(size = 16, face = "bold", color = "black", family = "serif")) 
    }
    
  } 
  
  if(!show_itr & !plot_cnumb) {
    
    cvec <- cond.4.nofn(at, nbs, classVector = at$cvec, nbs_of = 1, conditions = cond, 
                        class = 1, directional = d, max.iter = mi, fn_perc = fnp)
    cvec_cell <- at$Cell[which(!is.na(cvec))]
    
    m_long$whites[m_long$cnumb %in% cvec_cell] <- m_long$value[m_long$cnumb %in% cvec_cell]
    
    m_long$tags[m_long$cnumb %in% cvec_cell] <- "CL"
    m_long$tags[m_long$cnumb %in% fcells]    <- "FC"
    
    m_long$tags <- as.factor(m_long$tags)
    m_long$tags <- factor(m_long$tags, levels = c("FC", "CL"))
    
    p <- ggplot(m_long, aes(x=Var1, y=Var2)) +
      geom_tile(aes(fill=tags), colour="gray90", lwd=1.5, show.legend = FALSE) +
      coord_fixed(ratio=1) + 
      geom_text(aes(label=value), color = "grey50", family=c("serif"), size=txt_size) + 
      geom_text(aes(label=whites), color = "white", family=c("serif"), size=txt_size) +
      scale_fill_manual(values = c("#1088a0", "#78b2c4"), na.value = "black") + 
      theme_void() + 
      scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0))
    
    if(!is.null(title_txt)){
      
      p <- p + ggplot2::labs(title = title_txt) + 
        theme(plot.title=element_text(size = 16, face = "bold", color = "black", family = "serif")) 
    }
    
  } 
  
  if(show_itr){
    itr <- 0
    continue <- TRUE
    
    l_plot <- list()
    
    while(continue){
      
      cvec_cell <- at$Cell[which(!is.na(at$cvec))]
      
      m_long$whites[m_long$cnumb %in% cvec_cell] <- m_long$value[m_long$cnumb %in% cvec_cell]
      
      m_long$tags[m_long$cnumb %in% cvec_cell] <- "CL"
      m_long$tags[m_long$cnumb %in% fcells]    <- "FC"
      
      m_long$tags <- as.factor(m_long$tags)
      m_long$tags <- factor(m_long$tags, levels = c("FC", "CL"))
      
      p <- ggplot(m_long, aes(x=Var1, y=Var2)) +
        geom_tile(aes(fill=tags), colour="gray90", lwd=1.5, show.legend = FALSE) +
        coord_fixed(ratio=1) + 
        geom_text(aes(label=value), color = "grey50", family=c("serif"), size=txt_size) + 
        geom_text(aes(label=whites), color = "white", family=c("serif"), size=txt_size) +
        scale_fill_manual(values = c("#1088a0", "#78b2c4"), na.value = "black") + 
        theme_void() + 
        scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0))
      
      if(!is.null(title_txt)){
        
        p <- p + ggplot2::labs(title = title_txt) + 
          theme(plot.title=element_text(size = 16, face = "bold", color = "black", family = "serif")) 
        
      } else {
        
        p <- p + ggplot2::labs(title = paste0("Iteration: ", itr)) + 
          theme(plot.title=element_text(size = 16, face = "bold", color = "black", family = "serif")) 
      }
      
      l_plot[[paste0("itr_", itr)]] <- p
      
      cv_test <- cond.4.nofn(at, nbs, classVector = at$cvec, nbs_of = 1, conditions = cond, 
                             class = 1, directional = d, max.iter = 1, fn_perc = fnp)
      
      if( sum(cv_test == 1, na.rm = TRUE) == sum(at$cv == 1, na.rm = TRUE) ){
        continue <- FALSE
      } else {
        at$cvec <- cv_test
      }
      
      itr <- itr + 1
      
    }
    
    p <- l_plot
    
  }
  
  return(p)
  
}
```

<a id="figure1"></a>

```{r def, message=FALSE, warning=FALSE, echo=FALSE}
# MATRIX NUMBER
m     <- matrix(1:49, nrow = 7, ncol = 7, byrow = TRUE)

r   <- raster(m)
nbs <- ngbList(r)

m <- t(m)[,nrow(m):1]
m_long <- melt(m)

m_long$tags[m_long$value == 32] <- "FC"
m_long$tags[m_long$value == 25] <- "TC"

npool <- unique(unlist(nbs[c("32", "25")]))
m_long$whites[m_long$value %in% npool] <- m_long$value[m_long$value %in% npool]


m_long$tags <- as.factor(m_long$tags)


p1 <- ggplot(m_long, aes(x=Var1, y=Var2)) +
  geom_tile(aes(fill=tags), colour="gray90", lwd=1.5, show.legend = FALSE) +
  coord_fixed(ratio=1) + 
  geom_text(aes(label=value), color = "grey50", family=c("serif"), size=8) + 
  geom_text(aes(label=whites), color = "white", family=c("serif"), size=8) + 
  scale_fill_manual(values = c("#1088a0", "goldenrod3"), na.value = "black") + 
  geom_rect(aes(xmin = 2.5, xmax = 5.5, ymin = 1.5, ymax = 4.5), fill = "transparent", color="#1088a0", lwd = 1.5) + 
  geom_rect(aes(xmin = 2.5, xmax = 5.5, ymin = 2.5, ymax = 5.5), fill = "transparent", color="goldenrod3", lwd = 1.5) +
  geom_rect(aes(xmin = 2.6, xmax = 5.4, ymin = 2.6, ymax = 4.4), fill = "transparent", color="red", lwd = 1.2) +
  theme_void()  + 
  scale_x_discrete(expand=c(0,0)) + scale_y_discrete(expand=c(0,0)) + 
  labs(title = "Cell numbers") + 
          theme(plot.title=element_text(size = 16, face = "bold", color = "black", family = "serif")) 


# MATRIX DATA 
m  <- matrix(1,nrow = 7, ncol = 7, byrow = TRUE)
r   <- raster(m)
nbs <- ngbList(r)
# nbs <- nbs_m

r[20] <- 10

n1 <- nbs[["20"]]
r[n1] <- 5

n2 <- setdiff(unique(unlist(nbs[n1])), n1)
r[n2] <- 3

r[20] <- 10
r[c(34,35)] <- 2
####

r[43] <- 8
n1 <- nbs[["43"]]
r[n1] <- 5

n2 <- setdiff(unique(unlist(nbs[n1])), n1)
r[n2] <- 2
r[43] <- 8

m <- as.matrix(r)

# PLOT
p2 <- test_plots(fcells = 32, m, cond = FALSE, title_txt = "Raster layer: 'dummy_var'", txt_size = 7)

pn <- NULL
 
ggarrange(p1, pn, p2, nrow = 1, widths = c(1,0.1,1))
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 1** - On the left, raster values correspond to cell numbers (`1:49`). **The focal cell** is cell number 32 (in blue). The **test cell** is cell number 25 (in yellow). **The focal cell neighborhood** is marked by the blue border (cells `24,25,26,31,33,38,39,40`). **The test cell neighborhood** is marked by the yellow border (cells `17,18,19,24,26,31,32,33`). **The directional neighborhood** is marked by the red border (cells `24,25,26,31,32,33`). On the right, a dummy raster layer named `'dummy_var'`.</span></div>


## Types of classification rules

The dummy raster of [figure 1](#figure1) will be used to illustrate the different types of classification rules used by `scapesClassification` functions. Additional information can be found in the documentation of the function `conditions()` and in the article ["classification functions"](scapesClassification_01_4_ClassFunctions.html).

### Absolute conditions

Absolute conditions compare a variable value against a user-defined threshold value. There are two types of absolute conditions: (i) _absolute test cell rule_ and (ii) _absolute neighborhood rule_ ([Figure 2](#figure2)). 

i. **Absolute test cell rule.** Compares the _test cell_ value against a threshold value. Test cells are classified if the rule evaluation is true. 
    
ii. **Absolute neighborhood rule.** Compares the values of the _test cell_ and of its _neighborhood_ against a threshold value and has the following properties:

    * It is identified by a variable name followed by curly brackets (e.g., `'dummy_var{}'`);
    
    * A maximum of 9 evaluations are performed for each test cell (the test cell itself and its neighborhood are compared against a threshold value);
    
    * Test cells are classified if the rule is true for at least as many evaluations as the ones specified by the argument `fn_perc`. In [figure 2](#figure2) `fn_perc` is set to 60%, meaning that test cells are classified if the condition is true for at least 6 out of the 9 cells comprising the test cell and its neighborhood (60% of 9 evaluations is equal to 5.4 true evaluations);
        
    * Only one neighborhood rule is allowed for each condition string (e.g., it is not possible to have a condition string like `'dummy_var1{} > 0 & dummy_var2{} > 1'`).

<a id="figure2"></a>

```{r figure2, message=FALSE, warning=FALSE, echo=FALSE}
p1 <- test_plots(fcells = 32, m, cond = "dummy_var >= 3", mi = 1,
                 title_txt = "Absolute test cell rule", txt_size = 7)

p2 <- test_plots(fcells = 32, m, cond = "dummy_var{} >= 3", fnp = 0.6, mi = 1,
                 title_txt = "Absolute neighborhood rule (tag {})", txt_size = 7)

p1 <- p1 + labs(subtitle = "Rule: dummy_var >= 3 \nfn_perc = N/A") +
  theme(plot.subtitle=element_text(size = 12, color = "black", 
                                family = "serif"))

p2 <- p2 + labs(subtitle = "Rule: dummy_var{} >= 3 \nfn_perc = 60%") +
  theme(plot.subtitle=element_text(size = 12, color = "black", 
                                family = "serif"))

ggarrange(p1, pn, p2, nrow = 1, widths = c(1,0.1,1))
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 2 - Absolute conditions.** The initial focal cell is showed in dark blue; cells in the focal cell neighborhood meeting the classification rule are showed in light blue. **On the left**, absolute test cell rule `'dummy_var >= 3'`. Test cells are classified if their value is >= 3. **On the right**, absolute neighborhood rule `'dummy_var{} >= 3'` with `fn_perc = 60%`. Test cells are classified if at least 6 out of the 9 cells comprising the test cell and its neighborhood have values >= 3 (60% of 9 evaluations is equal to 5.4 true evaluations).</span></div>


### Relative conditions

Relative conditions compare the values of contiguous cells. There are two types of relative conditions: (i) _relative focal cell rule_ and (ii) _relative neighborhood rule_ ([Figure 3](#figure3)). 

i. **Relative focal cell rule.** Compares the _test cell_ value against the _focal cell_ value and has the following properties:

    * It is identified by a variable name followed by square brackets (e.g., `'dummy_var[]'`);
    
    * Rules are defined repeating twice the same variable name, once with square brackets and once without. Square brackets indicate the focal cell value. In [figure 3](#figure3) the rule `'dummy_var < dummy_var[]'` compares the value of the the test cell (`dummy_var`) against the value of the focal cell (`dummy_var[]`);
    
    * Test cells are classified if the rule is true. 
    
ii. **Relative neighborhood rule.** Compares the values of the _test cell_ against the values of its _neighborhood_ and has the following properties:

    * It is identified by a variable name followed by curly brackets (e.g., `'dummy_var{}'`);
    
    * Rules are defined repeating twice the same variable name, once with curly brabrackets and once without. Curly brackets indicate the test cell neighborhood. In [figure 3](#figure3) the rule `'dummy_var < dummy_var{}'` compares the value of the the test cell (`dummy_var`) against the values of the test cell neighborhood (`dummy_var{}`).

    * Test cells are classified if the rule is true for at least as many evaluations as the ones specified by the argument `fn_perc`. In [figure 3](#figure3) `fn_perc` is set to 60%, meaning that test cells are classified if the value of the test cell is smaller than 5 or more neighbors (60% of 8 evaluations is equal to 4.8 true evaluations); 
    
    * Only one neighborhood rule is allowed for each condition string (e.g., it is not possible to have a condition string like `'dummy_var1{} > dummy_var1 & dummy_var2{} > 1'`).

<a id="figure3"></a>

```{r figure3, message=FALSE, warning=FALSE, echo=FALSE}
p1 <- test_plots(fcells = 32, m, cond = "dummy_var < dummy_var[]", mi = 1,
                 title_txt = "Relative focal cell rule (tag [])")

p1 <- p1 + labs(subtitle = "Rule: 'dummy_var < dummy_var[]' \nfn_perc = N/A") +
  theme(plot.subtitle=element_text(size = 12, color = "black", 
                                   family = "serif"))

p2 <- test_plots(fcells = 32, m, cond = "dummy_var < dummy_var{}", fnp = 0.6, mi = 1,
                 title_txt = "Relative neighborhood rule (tag {})")

p2 <- p2 + labs(subtitle = "Rule: 'dummy_var < dummy_var{}' \nfn_perc = 60%") +
  theme(plot.subtitle=element_text(size = 12, color = "black", 
                                   family = "serif"))

ggarrange(p1, pn, p2, nrow = 1, widths = c(1,0.1,1))
```

<div style="line-height: 0.8em; margin-bottom: 1.5em;"><span class="legend">**Figure 3 - Relative conditions.** The initial focal cell is showed in dark blue; cells in the focal cell neighborhood meeting the classification rule are showed in light blue. **On the left**, relative focal cell rule `'dummy_var < dummy_var[]'`. Test cells are classified if their value is smaller than the value of the focal cell. **On the right**, relative neighborhood rule `'dummy_var < dummy_var{}'` with `fn_perc = 60%`. Test cells are classified if their value is smaller than 5 or more neighbors (60% of 8 evaluations is equal to 4.8 true evaluations).</span></div>



